
 <!DOCTYPE HTML>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  
    <title>javascript笔记 | guopengsong</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=3, minimum-scale=1">
    
    <meta name="author" content="郭鹏松">
    
    <meta name="description" content="css引入入到页面的几种方式1、行内式；2、内嵌式（将css写在style标签里面，放在head里面）；3、外链式（只是将内嵌式中的css样式放在一个单独的css文件中，通过link标签引入）；4、导入式（语法@import “css/index.css”）；
js引入到页面中的几种方式1、行内引入">
    
    
    
    
    
    <link rel="icon" href="/img/favicon.ico">
    
    
    <link rel="apple-touch-icon" href="/img/corpse.jpg">
    <link rel="apple-touch-icon-precomposed" href="/img/corpse.jpg">
    
    <link rel="stylesheet" href="/css/style.css">
</head>

  <body>
    <header>
      <div>
		
			<div id="imglogo">
				<a href="/"><img src="/img/corpse.png" alt="guopengsong" title="guopengsong"/></a>
			</div>
			
			<div id="textlogo">
				<h1 class="site-name"><a href="/" title="guopengsong">guopengsong</a></h1>
				<h2 class="blog-motto">每一个不曾起舞的日子都是对生命的辜负</h2>
			</div>
			<div class="navbar"><a class="navbutton navmobile" href="#" title="菜单">
			</a></div>
			<nav class="animated">
				<ul>
					<ul>
					 
						<li><a href="/">主页</a></li>
					
						<li><a href="/archives">归档</a></li>
					
						<li><a href="/categories/javascript">javascript</a></li>
					
						<li><a href="/categories/news">新闻</a></li>
					
						<li><a href="/about">关于</a></li>
					
					<li>
					
					<form class="search" action="//google.com/search" method="get" accept-charset="utf-8">
						<label>Search</label>
						<input type="text" id="search" name="q" autocomplete="off" maxlength="20" placeholder="搜索" />
						<input type="hidden" name="q" value="site:github.com/guoPengSong">
					</form>
					
					</li>
				</ul>
			</nav>			
</div>

    </header>
    <div id="container">
      <div id="main" class="post" itemscope itemprop="blogPost">
	<article itemprop="articleBody"> 
		<header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2017/04/16/javascript/" title="javascript笔记" itemprop="url">javascript笔记</a>
  </h1>
  <p class="article-author">By
    
      <a href="https://github.com/guoPengSong" title="郭鹏松">郭鹏松</a>
    </p>
  <p class="article-time">
    <time datetime="2017-04-16T11:06:21.230Z" itemprop="datePublished">2017-04-16</time>
    更新日期:<time datetime="2017-04-16T12:55:54.919Z" itemprop="dateModified">2017-04-16</time>
    
  </p>
</header>
	<div class="article-content">
		
		
		<div id="toc" class="toc-article">
			<strong class="toc-title">文章目录</strong>
		<ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#css引入入到页面的几种方式"><span class="toc-number">1.</span> <span class="toc-text">css引入入到页面的几种方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#js引入到页面中的几种方式"><span class="toc-number">2.</span> <span class="toc-text">js引入到页面中的几种方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#js中常用的几种输出方式和控制台详解"><span class="toc-number">3.</span> <span class="toc-text">js中常用的几种输出方式和控制台详解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#js的组成和命名规范"><span class="toc-number">4.</span> <span class="toc-text">js的组成和命名规范</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#js中的变量和数据类型以及数据类型之间的转化"><span class="toc-number">5.</span> <span class="toc-text">js中的变量和数据类型以及数据类型之间的转化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#js中的判断的应用（开关灯）"><span class="toc-number">6.</span> <span class="toc-text">js中的判断的应用（开关灯）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#js中的三个循环"><span class="toc-number">7.</span> <span class="toc-text">js中的三个循环</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#js中隔行变色的原理"><span class="toc-number">8.</span> <span class="toc-text">js中隔行变色的原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#九九乘法表"><span class="toc-number">9.</span> <span class="toc-text">九九乘法表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#数组和数组的常用方法"><span class="toc-number">10.</span> <span class="toc-text">数组和数组的常用方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#冒泡排序"><span class="toc-number">11.</span> <span class="toc-text">冒泡排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#数组去重"><span class="toc-number">12.</span> <span class="toc-text">数组去重</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DOM获取元素的方法（8个）"><span class="toc-number">13.</span> <span class="toc-text">DOM获取元素的方法（8个）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DOM中的节点和关系属性"><span class="toc-number">14.</span> <span class="toc-text">DOM中的节点和关系属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#怎么写完整的注释"><span class="toc-number">15.</span> <span class="toc-text">怎么写完整的注释</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DOM的增删改"><span class="toc-number">16.</span> <span class="toc-text">DOM的增删改</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#setAttribute"><span class="toc-number">17.</span> <span class="toc-text">setAttribute</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Math的方法"><span class="toc-number">18.</span> <span class="toc-text">Math的方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#字符串方法和应用"><span class="toc-number">19.</span> <span class="toc-text">字符串方法和应用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Date"><span class="toc-number">20.</span> <span class="toc-text">Date</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#定时器原理和应用"><span class="toc-number">21.</span> <span class="toc-text">定时器原理和应用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#git和github"><span class="toc-number">22.</span> <span class="toc-text">git和github</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#学员更新老师讲义地址"><span class="toc-number">23.</span> <span class="toc-text">学员更新老师讲义地址</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#提交作业"><span class="toc-number">24.</span> <span class="toc-text">提交作业</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#预解释"><span class="toc-number">25.</span> <span class="toc-text">预解释</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#面向对象"><span class="toc-number">26.</span> <span class="toc-text">面向对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#正则"><span class="toc-number">27.</span> <span class="toc-text">正则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#js盒子模型"><span class="toc-number">28.</span> <span class="toc-text">js盒子模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#绑定数据的方式"><span class="toc-number">29.</span> <span class="toc-text">绑定数据的方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#跑马灯效果的核心"><span class="toc-number">30.</span> <span class="toc-text">跑马灯效果的核心</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#瀑布流的核心"><span class="toc-number">31.</span> <span class="toc-text">瀑布流的核心</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#运动"><span class="toc-number">32.</span> <span class="toc-text">运动</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#jQuery"><span class="toc-number">33.</span> <span class="toc-text">jQuery</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#jQuery-1"><span class="toc-number">34.</span> <span class="toc-text">jQuery</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#事件"><span class="toc-number">35.</span> <span class="toc-text">事件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#放大镜效果原理"><span class="toc-number">36.</span> <span class="toc-text">放大镜效果原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#拉勾网穿墙效果原理"><span class="toc-number">37.</span> <span class="toc-text">拉勾网穿墙效果原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#………"><span class="toc-number">38.</span> <span class="toc-text">………..</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#附录"><span class="toc-number"></span> <span class="toc-text">附录</span></a>
		</div>
		
		<h3 id="css引入入到页面的几种方式"><a href="#css引入入到页面的几种方式" class="headerlink" title="css引入入到页面的几种方式"></a>css引入入到页面的几种方式</h3><p>1、行内式；<br>2、内嵌式（将css写在style标签里面，放在head里面）；<br>3、外链式（只是将内嵌式中的css样式放在一个单独的css文件中，通过link标签引入）；<br>4、导入式（语法@import “css/index.css”）；</p>
<h3 id="js引入到页面中的几种方式"><a href="#js引入到页面中的几种方式" class="headerlink" title="js引入到页面中的几种方式"></a>js引入到页面中的几种方式</h3><p>1、行内引入（不推荐）安全性能低，能通过控制台修改<br>代码示例<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;div onclick="alert('1')"&gt;&lt;/div&gt;</div></pre></td></tr></table></figure></p>
<p>2、内嵌式（把js写在script标签里面）；<br>3、外链式（把js文件放在一个单独的JavaScript文件内，通过script标签的src属性引入）；<br><code>在外链式中script标签中间不可以写js代码，写了也不会执行</code><br>代码示例<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;script type="text/javascript" src="js/index.js"&gt;</div><div class="line">	console.log(1)//这里的代码不会执行</div><div class="line">&lt;/script&gt;</div></pre></td></tr></table></figure></p>
<p><strong>总结</strong><br>为什么css放在head里面？<br>因为html是从上到下加载，得先加载好样式，然后加载结构，增强用户体验；<br>为什么将js放在body后面？<br>因为html是从上到下加载，js通常是获取html标签然后给予动态效果的，所以需要先加载html标签再加载js</p>
<h3 id="js中常用的几种输出方式和控制台详解"><a href="#js中常用的几种输出方式和控制台详解" class="headerlink" title="js中常用的几种输出方式和控制台详解"></a>js中常用的几种输出方式和控制台详解</h3><p><strong>输出方式</strong><br>1、alert(“输出内容”)在页面中弹出一个框，把要输出的内容<code>先转化成字符串再输出</code><br>2、console.log(“输出内容”)在控制台console中输出内容，最常用的输出方式<br>3、console.dir在控制台输出一个对象的详细信息<br>4、console.table把一个json数据按照表格的形势输出，查看结构更加清晰<br>5、document.write(“输出内容”)在页面中输出显示我们的内容，用于在页面中添加一个广告<br>6、innerHTML(“输出内容”)和innerText(“输出内容”)向指定元素动态添加内容<br>7、confirm()浏览器中确认弹出层，当用户选择确定，方法返回true，用户选择取消，方法返回false，我们通过方法返回的值进行对应的操作<br><img src="./confirm.png" alt="Alt text"></p>
<p><strong>innerHTML和innerText的区别</strong></p>
<ul>
<li>firefox浏览器不支持innerText</li>
<li>innerHTML不仅能添加文字还能添加html标签而innerText不能识别html标签，把标签也当做文字添加进去<br><strong>控制台详解</strong></li>
<li>Elements：我们页面中的所有元素都在这个里面，我们经常用这个来调试我们的样式（火狐浏览器中安装一个firebug插件，也可以调试样式）；</li>
<li>Console：页面中在控制台输出的内容在这里面</li>
<li>Network：包含了我们索引的资源文件（HTML、CSS、JS、图片、数据接口），并且告诉我们每一个文件加载完成的时间，项目中通过Network对时间较长的进行优化；</li>
<li>Socuces：包含项目中的HTML、CSS、JS所有的源码，扒网站可以在这里找到所有源码，压缩过的源码点击左下角大括号可以解压</li>
<li>Resources：数据源的意思，本地存储数据（cookie、localstorage）都可以在这里查看<h3 id="js的组成和命名规范"><a href="#js的组成和命名规范" class="headerlink" title="js的组成和命名规范"></a>js的组成和命名规范</h3>浏览器(window浏览器对象)-&gt;文档(document文档对象)-&gt;html-&gt;head/body<br>js:javaScript是一门轻量级的脚本编程语言<br><strong>组成部分</strong><br>1、ECMAScript（4、5）定义了js里面的命名规范、变量、数据类型、基本语法、操作语句等最核心的东西<br>2、DOM document object model 文档对象模型，提供了所有关于文档里面的元素操作方式<br>3、BOM browser object model 浏览器对象模型，提供了所有关于浏览器的操作方式<br><strong>命名规范</strong><br>1、js中严格区分大小写<br>2、使用驼峰命名法（</li>
<li>首字母小写，其余的每个有意义的单词的首字母大写  例如：personInformation</li>
<li>可以使用数字、字母、下划线、$<code>（数字不能作为首字母、下划线开头通常是特殊变量、$开头通常作为jquery变量）</code><br>）<br>3、不能使用关键字和保留字<br>关键字：在js中有特殊意义的字<br>|break      |    case | catch|continue|default  |<br>| :——–: | :——–:| :–: | :–: | :–: |<br>| delete  | do |  else   |finally|for|<br>|function    |if|in    |instanceof|    new|<br>|return    |switch|this    |throw    |try|<br>|typeof    |var    |void    |while|with|<br>保留字：未来有可能成为关键字的<br>|abstract    |    boolean    | byte    |char    |class|<br>| :——–: | :——–:| :–: | :–: | :–: |<br>|const    |debugger    |double|    enum|    export|<br>|extends|    final|    float|    goto    |implements|<br>|import|    int    |interface|    long|    native|<br>|package|    private|    protected|    public|    short|<br>|static    |super    |synchronized|    throws    |transient|<br>|volatile            |<h3 id="js中的变量和数据类型以及数据类型之间的转化"><a href="#js中的变量和数据类型以及数据类型之间的转化" class="headerlink" title="js中的变量和数据类型以及数据类型之间的转化"></a>js中的变量和数据类型以及数据类型之间的转化</h3>变量是一个抽象的概念，变量是用来存储值和代表值的<br>js中定义变量用var，代码示例<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">var name=&quot;张三&quot;;</div><div class="line">``` </div><div class="line">---</div><div class="line"></div><div class="line">`js中的变量是松散类型的，可以存储任何数据类型的数据`</div><div class="line">**`js中的数据类型分为基本数据类型和引用数据类型`**</div><div class="line">基本数据类型：</div><div class="line">数字（number）、字符串（string）、布尔值（boolean）、null、undefined</div><div class="line">引用数据类型：</div><div class="line">对象数据类型（object）、函数数据类型（function）</div><div class="line">#### 数据类型number</div><div class="line">number数据类型包含：正数、负数、小数、0和NaN（not a number不是一个有效数字，但是属于number数据类型）</div><div class="line">`=`是赋值</div><div class="line">`==`是判断是否相等，会做数据类型转换</div><div class="line">`===`是判断是否绝对相等，数据类型也必须相同</div><div class="line">`NaN==NaN是false，因为不是有效数字，没办法作比较`</div><div class="line">isNaN()检测一个值是不是NaN，是NaN返回true，是有效数字返回false；如果检测的不是number类型的，就会先进行数据类型的转换，然后再进行比较</div><div class="line">#### 数据类型boolean</div><div class="line">`！`是取反的意思，首先将值转换成布尔类型的再取反</div><div class="line">`！！`是将其它数据类型转化成布尔类型，相当于Boolean();</div><div class="line">####数据类型object</div><div class="line">js中的对象数据类型由属性名和属性值组成，也就是键值对，属性名和属性值是用来描述这个对象特征的，属性名不能重复；</div><div class="line">可以通过`obj.name`和`obj[&quot;name&quot;]`这两种方式获得属性值，如果属性名是数字，只能通过`obj[&quot;1&quot;]`来获取属性值</div></pre></td></tr></table></figure>
</li>
</ul>
<p>var obj={<br>        “name”:”张三”,<br>        “age”:”18”，<br>        “height”:”180cm”,<br>        “weight”:”80kg”<br>    }//这是字面量创建方式<br>var obj=new Object();//实例创建方式<br>obj.name=”张三”;<br>obj[“name”]=”张三”//这两种方法都可以增加和修改对象的属性值;<br>console.log(obj.name);<br>console.log(obj[“name”]);//这两种方法是获取属性值,如果属性名不存在，返回结果是undefined<br>//假删除<br>obj.name=null;<br>//真删除<br>delete obj.name;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">对象数据类型还可以具体细分：包含对象类（Object）、数组类（Array）、正则类（Regexp）、时间类（Date）、Math数学函数……等对应的实例</div><div class="line">**js中对象、类、实例的区别**</div><div class="line">对象是泛指，js中万物皆对象，类是对对象的具体细分，实例是类中的一个具体的事物；</div><div class="line">####数据类型function</div><div class="line">定义function的步骤：①开辟一个新的堆内存②把函数体中的js代码当做字符串存进内存空间去③再把堆内存地址给函数名</div></pre></td></tr></table></figure></p>
<pre><code>function fn(){
    //这里面是函数体
}
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">js中function的一个特别大的作用（封装）：实现一个功能的代码的封装，以后再实现这个功能代码没有必要重新写了，只要执行这个方法就行了;</div><div class="line">通过传递参数的不同，实现不同的功能叫做函数的`多态`；</div><div class="line">定义形参没传值，默认值是undefined；</div><div class="line">arguments是一个类数组（由数字作为索引，有length属性），所有的类数组都是对象数据类型，是函数内部接收参数的机制，不管是否写形参也不管是否传递参数，arguments一直存在；</div><div class="line">arguments.callee代表当前函数本身；</div><div class="line">arguments中获取其中某一个只能用arguments[索引]，不能用arguments.item();</div><div class="line">利用arguments进行任意数求和，代码示例</div></pre></td></tr></table></figure>
<pre><code>function sum(){
    var total=0;
    for(var i=0;i&lt;arguments.length;i++){
        var cur=arguments[i];
        cur=Number(cur);
        if(!isNaN(cur)){
            total+=cur;
        }
    }
    return total;//外面想用什么直接在函数体里面return就可以了
}
var total=sum(1,2,&quot;3&quot;,&quot;a&quot;)//把函数执行完成的整体返回值赋值给外面这个total变量
console.log(total);
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div></pre></td><td class="code"><pre><div class="line">**闭包**</div><div class="line">函数执行的时候会形成一个私有的作用于来保护里面的变量不受外界的干扰，我们把这种机制叫做闭包</div><div class="line">**函数中的return的机制**</div><div class="line">函数中如果没写return默认返回值是undefined</div><div class="line">函数中外面想用什么直接在函数体里面return就可以了</div><div class="line">函数中return后面的代码不再执行，应用于控制函数中代码执行到指定位置就结束</div><div class="line">**匿名函数**</div><div class="line">匿名函数一般有两种情况①函数表达式（把匿名函数的定义部分当做值赋值给一个变量或者一个元素的事件）</div><div class="line">	例如var fn=function()&#123;console.log(&quot;这是一个函数表达式&quot;)&#125;或者是绑定事件函数或者定时器都是函数表达式；</div><div class="line">	②自执行函数</div><div class="line">	语法</div><div class="line">``` python</div><div class="line">//以下都是自执行函数</div><div class="line">;(function()&#123;&#125;)();</div><div class="line">    </div><div class="line">~function()&#123;&#125;();</div><div class="line"></div><div class="line">!function()&#123;&#125;();</div><div class="line"></div><div class="line">+function()&#123;&#125;();</div><div class="line"></div><div class="line">-function()&#123;&#125;();</div><div class="line">``` </div><div class="line">#### 数据类型之间的转化</div><div class="line">number中的强制数据类型转化（Number()）</div><div class="line">``` python</div><div class="line">Number()//强制把其他数据类型转化成number类型，如果是字符串,字符串中必须都是数字才可以转化，只要有一个不是有效数字就会返回NaN</div><div class="line">Number(&quot;123&quot;)//返回123</div><div class="line">Number(&quot;12px&quot;)//返回NaN</div><div class="line">Number(&quot;12.5&quot;)//返回12.5</div><div class="line">Number(&quot;&quot;)//返回0</div><div class="line">``` </div><div class="line">number中非强制数据类型转化parseInt和parseFloat</div><div class="line">``` python</div><div class="line">parseInt()//从左到右一个个字符查找，把是数字的转化成有效数字，中途如果遇到了一个非有效数字，就不在继续查找了，如果第一个不是有效数字返回NaN</div><div class="line">parseInt(&quot;12px&quot;)//返回值是12</div><div class="line">parseInt(&quot;12.5px&quot;)//返回值是12</div><div class="line">parseInt(&quot;xiaoguo000&quot;)//返回值是NaN</div><div class="line">parseFloat()//和parseInt一样，但是能识别小数点</div><div class="line">parseInt(&quot;12.5px&quot;)//返回值是12.5</div><div class="line">``` </div><div class="line">**数据类型的转化规则**</div><div class="line">1、如果只有一个数值，判读真假，遵循：只有0、NaN、&quot;&quot;、null、undefined这5个是假，其余都是真;如下表</div><div class="line">自身做布尔类型运算的时候的转化</div><div class="line">|类型	| 规律	|示例|</div><div class="line">| :--------: | :--------:| :--: |</div><div class="line">|object	|都是true| 	 alert(!![])|</div><div class="line">|number|	只是0和NaN是false|	 alert(!!0);|</div><div class="line">|string|	只有空字符串是false（不是空格字符串）|	 alert(!!&quot;&quot;);|</div><div class="line">|function|	都是ture	 |</div><div class="line">|null,undefined	|都是false|	</div><div class="line">2、不同数据类型之间比较的时候数据类型之间的转化</div><div class="line">|类型	|    类型	| 规律	|其它说明|</div><div class="line">| :--------: | :--------:| :--: | :--: |</div><div class="line">| 对象	| 对象	|  比较是不是同一个内存地址	 ||</div><div class="line">|对象	|字符串|对象先转化为字符串，然后做比较|调用对象的toString方法，[]转化为字符串是&quot;&quot;,&#123;&#125;转化成字符串是[object Object]|</div><div class="line">|对象	|布尔类型|两边都要先转为数字（false是0，true是1）。是对象类型先隐式调用toString方法，然后再Number()|alert([]==false);alert([]==0)；alert([1]==1);alert([1]==true)；alert([2]==true)||</div><div class="line">|对象	|数字	|对象要转为数字，再进行比较(对象先隐式调用toString方法转化为字符串，然后再把这个字符串轮化为数字，相当于把这个字符串放到Number这个方法中)||</div><div class="line">|数字	|布尔|是进行的数字的比较||</div><div class="line">|数字	|字符串	|把字符串转化为数字，再比较	||</div><div class="line">|布尔	|字符串|把两边都要转化为数字再进行比较||</div><div class="line">|null	|undefined	|true||</div><div class="line">|null,undefined	|和其它类型	|null和undefined和其它类型比较都是false(这两个对象没toString方法)|alert(null==false)；alert(null==0)；alert(null==&quot;&quot;);|</div><div class="line">### 数据类型的区分和数据类型的检测</div><div class="line">#### 基本数据类型和引用数据类型的本质区别</div><div class="line">基本数据类型是直接操作值，引用数据类型操作的是对空间的引用地址（先定义一个变量，然后开辟一个内存，将属性名和属性值保存在这个空间，然后将这个地址 赋给变量）</div><div class="line">#### js中检测数据类型的方式</div><div class="line">- typeof运算符   `返回值是一个字符串，可能是&quot;number&quot;、&quot;string&quot;、&quot;boolean&quot;、&quot;undefined&quot;、&quot;object&quot;、&quot;function&quot;，typeof null的结果是&quot;object&quot;`typeof有局限性，不能具体检查object下的细分的类型例如数组、正则，检查的返回结果都是&quot;object&quot;;</div><div class="line">- instanceof运算符</div><div class="line">- constructor</div><div class="line">- Object.prototype.toString.call()</div><div class="line">### js中的三个判断语句</div><div class="line">- **if else**  能解决所有的判断</div><div class="line">语法：</div></pre></td></tr></table></figure>
<pre><code>if(条件1){
    条件1成立时执行的代码
}else if(条件2){
    条件1成立时执行的代码
}else{
    以上情况都不成立时执行的代码
}
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">- **三元运算符**   应用于简单的if else情况</div><div class="line">语法：</div><div class="line">``` python</div><div class="line">	var num=1;</div><div class="line">    num&gt;=0?console.log(&quot;正数或0&quot;):console.log(&quot;负数&quot;);</div><div class="line">    num&gt;=0?(console.log(&quot;可能是正数&quot;),console.log(&quot;也可能是0&quot;)):console.log(&quot;负数&quot;);</div></pre></td></tr></table></figure>
<p><strong>三元运算符条件成立执行多条语句的时候，用括号包起来，每条语句之间用逗号隔开</strong></p>
<ul>
<li><strong>switch case</strong>  应用于不同值下的不同操作<br><code>每一种case情况下都要加break，default不需要加break,如果不加break，不管后面的代码是否成立都会执行，每一种case情况都相当于===比较，注意数据类型是否相同</code><br>语法：<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">var num=10;</div><div class="line">   switch (num)&#123;</div><div class="line">       case 0:</div><div class="line">           console.log(0);</div><div class="line">           break;//每一种case情况下都要加break,如果不加break，不管后面的代码是否成立都会执行</div><div class="line">       case 10:</div><div class="line">           console.log(10);</div><div class="line">           break;</div><div class="line">       case 100:</div><div class="line">           console.log(100);</div><div class="line">           break;</div><div class="line">       default :</div><div class="line">           console.log(&quot;其他&quot;);</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="js中的判断的应用（开关灯）"><a href="#js中的判断的应用（开关灯）" class="headerlink" title="js中的判断的应用（开关灯）"></a>js中的判断的应用（开关灯）</h3><p>document.getElementById中document是上下文（context 限定获取元素的范围）通过id获取元素的上下文只能是document<br>元素.style.backgroundColor获取的是<code>行内样式</code>上的背景色<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">var oBody=document.getElementById(&quot;oBody&quot;);</div><div class="line">    oBody.onclick=function()&#123;</div><div class="line">        var bg=oBody.style.backgroundColor;</div><div class="line">        switch (bg)&#123;</div><div class="line">            case &quot;white&quot;:</div><div class="line">                oBody.style.backgroundColor=&quot;black&quot;;</div><div class="line">                break;</div><div class="line">            default :</div><div class="line">                oBody.style.backgroundColor=&quot;white&quot;;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<h3 id="js中的三个循环"><a href="#js中的三个循环" class="headerlink" title="js中的三个循环"></a>js中的三个循环</h3><ul>
<li><p>for循环<br>四部曲：1、设置初始值  var i=0;</p>
<pre><code>2、设置循环条件 i&lt;5;
3、执行循环体中的内容
4、循环体执行完后，执行累加操作 i++;
</code></pre><p><code>break</code>:在循环体中出现break，结束整个循环，累加操作不再执行；<br><code>continue</code>：在循环体中出现continue，结束当前这一轮的循环继续下一轮循环，累加操作继续执行<br>在循环体中遇到这两个关键字，循环体中关键字后面的代码就不再执行了<br>语法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">for(var i=0;i&lt;5;i++)&#123;</div><div class="line">       console.log(i)</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
</li>
<li><p>for in循环</p>
</li>
</ul>
<p><code>for in循环只能遍历自定义的属性和方法（包括私有的和原型链上公有的）</code><br><code>propertyIsEnumerable</code>:判断私有的属性和方法是不是可枚举的，跟hasOwnProperty<br>通常用来循环一个对象中的属性名和属性值的，对象中有多少键值对就循环几次；<br>在for in循环中只能<code>obj[key]</code>这么获得属性值，如果以打点的方式会得到undefined，因为obj中没有key这个属性；<br>如果对象中有数字作为属性名，首先循环数字属性名（按照从小到大的顺序），剩下的属性名按照我们写的顺序<br>语法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">var obj=&#123;</div><div class="line">       name:&quot;张三&quot;,</div><div class="line">       age:18,</div><div class="line">       height:180,</div><div class="line">       weight:80,</div><div class="line">       birthday:19990206</div><div class="line">   &#125;;</div><div class="line">   for(var key in obj)&#123;</div><div class="line">       console.log(key+obj[key]);//在for in循环中只能这么获得属性值</div><div class="line">   &#125;</div></pre></td></tr></table></figure></p>
<ul>
<li>while循环<br>语法：<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var i=0;</div><div class="line">   while(i&lt;5)&#123;</div><div class="line">       i++;</div><div class="line">   &#125;</div><div class="line">   console.log(i);</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="js中隔行变色的原理"><a href="#js中隔行变色的原理" class="headerlink" title="js中隔行变色的原理"></a>js中隔行变色的原理</h3><p>隔行变色的原理是操作所有的li，给不同行添加不同的类名达到隔行变色的效果；<br>设置li的类名用oLi[0].<code>className</code>=’c1’;<br>i%2的意思是i除以2取余数；<br>当用js增加鼠标滑过变色的效果时，用自定义属性的方式，鼠标划过时保存原来的类名改变类名，鼠标离开时恢复原来的类名</p>
<p>###选项卡<br>思路：当鼠标划到某一个li上面时，先让所有li与div都没有select样式，然后让鼠标滑过的li与对应的div有select样式就可以了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">//自定义属性的方式</div><div class="line">	var oTab=document.getElementById(&quot;tab&quot;);</div><div class="line">    var oLis=oTab.getElementsByTagName(&quot;li&quot;);</div><div class="line">    var oDivs=oTab.getElementsByTagName(&quot;div&quot;);</div><div class="line">    function tabChange(nIndex)&#123;</div><div class="line">        for(var i=0;i&lt;oLis.length;i++)&#123;</div><div class="line">            oLis[i].className=&quot;&quot;;</div><div class="line">            oDivs[i].className=&quot;&quot;;</div><div class="line">        &#125;</div><div class="line">        oLis[nIndex].className=&quot;select&quot;;</div><div class="line">        oDivs[nIndex].className=&quot;select&quot;;</div><div class="line">    &#125;</div><div class="line">    for(var i=0;i&lt;oLis.length;i++)&#123;</div><div class="line">        oLis[i].index=i;//在这里添加自定义属性</div><div class="line">        oLis[i].onmouseover=function()&#123;</div><div class="line">            tabChange(this.index);</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">//合并简化后的自定义属性方式，项目中基本这么写</div><div class="line">	var oTab=document.getElementById(&quot;tab&quot;);</div><div class="line">    var oLis=oTab.getElementsByTagName(&quot;li&quot;);</div><div class="line">    var oDivs=oTab.getElementsByTagName(&quot;div&quot;);</div><div class="line">    for(var i=0;i&lt;oLis.length;i++)&#123;</div><div class="line">        oLis[i].index=i;</div><div class="line">        oLis[i].onmouseover=function()&#123;</div><div class="line">            for(var j=0;j&lt;oLis.length;j++)&#123;</div><div class="line">                oLis[j].className=&quot;&quot;;</div><div class="line">                oDivs[j].className=&quot;&quot;;</div><div class="line">            &#125;</div><div class="line">            this.className=&quot;select&quot;;</div><div class="line">            oDivs[this.index].className=&quot;select&quot;;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">//用闭包的方式</div><div class="line">	var oTab=document.getElementById(<span class="string">"tab"</span>);</div><div class="line">    var oLis=oTab.getElementsByTagName(<span class="string">"li"</span>);</div><div class="line">    var oDivs=oTab.getElementsByTagName(<span class="string">"div"</span>);</div><div class="line">    <span class="keyword">for</span>(var i=<span class="number">0</span>;i&lt;oLis.length;i++)&#123;</div><div class="line">        (function()&#123;</div><div class="line">            oLis[i].onmouseover=function()&#123;</div><div class="line">                <span class="keyword">for</span>(var j=<span class="number">0</span>;j&lt;oLis.length;j++)&#123;</div><div class="line">                    oLis[j].className=<span class="string">""</span>;</div><div class="line">                    oDivs[j].className=<span class="string">""</span>;</div><div class="line">                &#125;</div><div class="line">                oLis[i].className=<span class="string">"select"</span>;</div><div class="line">                oDivs[i].className=<span class="string">"select"</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;)(i);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h3 id="九九乘法表"><a href="#九九乘法表" class="headerlink" title="九九乘法表"></a>九九乘法表</h3><p><strong>字符串拼接的规则</strong></p>
<ul>
<li>外面是双引号，里面就必须是单引号，外面是单引号，里面就必须是双引号</li>
<li>如果一个字符串中需要增加一个变量，看最外面是双引号还是单引号，如果是双引号，那么直接”+变量名+”；如果是单引号，那么’+变量名+’<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">var oTab=document.getElementById(<span class="string">"tab"</span>);</div><div class="line">var str=<span class="string">""</span>;</div><div class="line">str+=<span class="string">"&lt;ul&gt;"</span>;</div><div class="line"><span class="keyword">for</span>(var i=<span class="number">1</span>;i&lt;=<span class="number">9</span>;i++)&#123;</div><div class="line">    var val;</div><div class="line">    switch (i%<span class="number">3</span>)&#123;</div><div class="line">        case <span class="number">1</span>:</div><div class="line">            val=<span class="string">'c1'</span>;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        case <span class="number">2</span>:</div><div class="line">            val=<span class="string">'c2'</span>;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        default :</div><div class="line">            val=<span class="string">'c3'</span>;</div><div class="line">    &#125;</div><div class="line">    str+=<span class="string">"&lt;li class='"</span>+val+<span class="string">"'&gt;"</span>;</div><div class="line">        <span class="keyword">for</span>(var j=<span class="number">1</span>;j&lt;=i;j++)&#123;</div><div class="line">            str+=<span class="string">"&lt;span&gt;"</span>;</div><div class="line">                str+=j+<span class="string">"*"</span>+i+<span class="string">"="</span>+j*i;</div><div class="line">            str+=<span class="string">"&lt;/span&gt;"</span>;</div><div class="line">        &#125;</div><div class="line">    str+=<span class="string">"&lt;/li&gt;"</span>;</div><div class="line">&#125;</div><div class="line">str+=<span class="string">"&lt;/ul&gt;"</span>;</div><div class="line">oTab.innerHTML=str;</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="数组和数组的常用方法"><a href="#数组和数组的常用方法" class="headerlink" title="数组和数组的常用方法"></a>数组和数组的常用方法</h3><p>数组是由多个项组成的，每一项之间用逗号隔开，并且每一项存储的值可以是任何数据类型<br>方法是做什么用的，传递的参数是什么，返回值是什么，原数组是否改变<br><strong>第一组数组的增加、删除、修改</strong></p>
<ul>
<li><code>push</code>是向数组的末尾添加新内容，返回添加后新数组的长度，原有数组改变</li>
<li><code>unshift</code>是向数组的开头添加新内容，返回添加后新数组的长度，原有数组改变</li>
<li><code>splice(n,m,x)</code>是向数组的中间添加新内容，,把删除的内容当做新数组返回，原有数组改变<br>从索引n开始删除m个内容，把新增加的内容放在索引n的<code>前面</code><br><code>splice(n,m)</code>从索引n（包含n）开始删除m个内容,把删除的内容当做新数组返回，原有数组改变</li>
<li><code>pop</code>是删除数组最后一项，返回被删除的那一项，原有数组改变</li>
<li><code>shift</code>是删除数组第一项，返回被删除的那一项，原有数组改变<br><strong>第二组数组的查询和复制</strong></li>
<li><code>slice(n,m)</code>从索引n（包含n）开始找到索引m（不包含m）处，把找到的内容作为一个新的数组返回，原有数组不变<br><code>slice(n)</code>从索引n（包含n）开始，截取到数组的末尾<br><code>slice()</code>没有参数从索引0开始截取到末尾，相当于<code>slice(0)</code></li>
<li><code>concat</code>实现数组的拼接，返回值是拼接后的新数组,原数组不变;用法ary1.concat(ary2)<br><strong>第三组将数组转化成字符串</strong></li>
<li><code>toString</code>把数组中的每一项拿出来用逗号隔开，返回隔开后的字符串，原有数组不变</li>
<li><code>join(分隔符)</code>把数组中的每一项拿出来用指定分隔符隔开，返回隔开后的字符串，原有数组不变<br><code>eval()</code>是将字符串变成js表达式执行，用于数组中各项求和<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">eval(ary.join(<span class="string">"+"</span>))</div></pre></td></tr></table></figure>
</li>
</ul>
<p><strong>第四组数组的排列排序</strong></p>
<ul>
<li><code>reverse</code>把数组倒过来排列，返回排列后的新数组，原有数组改变</li>
<li><code>sort</code>数组的排序，可以实现由大到小，也可以实现由小到大排序，原有数组改变<br>sort遵循的是冒泡排序的思想<br>直接写ary.sort()只能处理10以内的排序，处理10以上的需要传递参数，这个参数是一个函数<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ary.sort(function(a,b)&#123;<span class="keyword">return</span> a-b;&#125;)//这是从小到大排序</div><div class="line">ary.sort(function(a,b)&#123;<span class="keyword">return</span> b-a;&#125;)//这是从大到小排序</div></pre></td></tr></table></figure>
</li>
</ul>
<p><strong>第五组常用但不兼容的方法</strong></p>
<ul>
<li><code>indexOf</code>判断数组是否包含某一项，包含返回索引，不包含返回-1；</li>
<li><code>forEach</code>循环数组中每一项 <code>IE6-8不兼容</code></li>
<li><code>map</code>循环数组中每一项，map需要传一个参数function，数组中的每一项都可以操作这个函数  <code>IE6-8不兼容</code><h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3>思想：当前项和后一项比较，如果当前项大于后一项，两者交换位置<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">var ary=[<span class="number">11</span>,<span class="number">9</span>,<span class="number">56</span>,<span class="number">21</span>,<span class="number">7</span>,<span class="number">15</span>,<span class="number">37</span>];</div><div class="line">   <span class="keyword">for</span>(var i=<span class="number">0</span>;i&lt;ary.length<span class="number">-1</span>;i++)&#123;</div><div class="line">       <span class="keyword">for</span>(var j=i+<span class="number">1</span>;j&lt;ary.length;j++)&#123;</div><div class="line">           <span class="keyword">if</span>(ary[j]&lt;ary[i])&#123;</div><div class="line">               var temp;</div><div class="line">               temp=ary[j];</div><div class="line">               ary[j]=ary[i];</div><div class="line">               ary[i]=temp;</div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">   console.log(ary);</div></pre></td></tr></table></figure>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">var ary=[<span class="number">11</span>,<span class="number">9</span>,<span class="number">56</span>,<span class="number">21</span>,<span class="number">7</span>,<span class="number">15</span>,<span class="number">37</span>];</div><div class="line">   <span class="keyword">for</span>(var i=<span class="number">0</span>;i&lt;ary.length<span class="number">-1</span>;i++)&#123;</div><div class="line">       <span class="keyword">for</span>(var j=<span class="number">0</span>;j&lt;ary.length<span class="number">-1</span>-i;j++)&#123;</div><div class="line">           <span class="keyword">if</span>(ary[j+<span class="number">1</span>]&lt;ary[j])&#123;</div><div class="line">               var temp;</div><div class="line">               temp=ary[j+<span class="number">1</span>];</div><div class="line">               ary[j+<span class="number">1</span>]=ary[j];</div><div class="line">               ary[j]=temp;</div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">   console.log(ary);</div></pre></td></tr></table></figure>
<h3 id="数组去重"><a href="#数组去重" class="headerlink" title="数组去重"></a>数组去重</h3><p><strong>双for循环的数组去重</strong><br>原理：把数组中的每一项拿出来与后面的项进行比较，重复删除，不重复，继续循环下一项<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">//双<span class="keyword">for</span>循环的数组去重</div><div class="line"><span class="keyword">for</span>(var i=<span class="number">0</span>;i&lt;ary.length<span class="number">-1</span>;i++)&#123;</div><div class="line">       var cur=ary[i];</div><div class="line">       <span class="keyword">for</span>(var j=i+<span class="number">1</span>;j&lt;ary.length;j++)&#123;</div><div class="line">           <span class="keyword">if</span>(cur==ary[j])&#123;</div><div class="line">               ary.splice(j,<span class="number">1</span>);</div><div class="line">               j--;//注意数组塌陷的问题</div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">   console.log(ary);</div></pre></td></tr></table></figure></p>
<p><strong>创建新数组的方式</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">//利用创建新数组的方式数组去重</div><div class="line">var ary1=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">1</span>];</div><div class="line">   var ary2=[];</div><div class="line">   <span class="keyword">for</span>(var i=<span class="number">0</span>;i&lt;ary1.length;i++)&#123;</div><div class="line">       <span class="keyword">if</span>(ary2.indexOf(ary1[i])==<span class="number">-1</span>)&#123;</div><div class="line">           ary2.push(ary1[i])</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">   console.log(ary2);</div></pre></td></tr></table></figure></p>
<p><strong>利用对象的数组去重</strong><br>原理：利用对象的属性名不能重复的原理，把数组中的每一项，当做一个新的属性名和属性值存起来，在存储的时候判断当前的属性名是否已经存在，存在了就代表数组该项重复了，我们直接删除，否则不重复，我们直接存储就好了<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">//利用对象的数组去重</div><div class="line">var ary=[<span class="number">11</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">11</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</div><div class="line">   var obj=&#123;&#125;;</div><div class="line">   <span class="keyword">for</span>(var i=<span class="number">0</span>;i&lt;ary.length;i++)&#123;</div><div class="line">       var cur=ary[i];</div><div class="line">       <span class="keyword">if</span>(obj[cur]==cur)&#123;//条件也可以写成判断obj[cur]是否存在</div><div class="line">           ary.splice(i,<span class="number">1</span>);</div><div class="line">           i--;</div><div class="line">           <span class="keyword">continue</span>;</div><div class="line">       &#125;</div><div class="line">       obj[cur]=cur;</div><div class="line">   &#125;</div><div class="line">   obj=null;</div><div class="line">   console.log(ary);</div></pre></td></tr></table></figure></p>
<h3 id="DOM获取元素的方法（8个）"><a href="#DOM获取元素的方法（8个）" class="headerlink" title="DOM获取元素的方法（8个）"></a>DOM获取元素的方法（8个）</h3><ul>
<li>document.getElementById(“”)<code>上下文只能是document</code>页面中如果id重复了，只获取第一个元素，在ie6-7中会把表单的name属性当作id来使用，ie6-7不区分id的大小写</li>
<li>contenxt.getElementsByTagName(“”)</li>
<li>document.getElementsByName(“”) 通过元素的name属性获取元素，<code>在ie下只对表单元素起作用，应用于获取表单元素</code></li>
<li>document.getElementsByClassName(“”) <code>IE6-8不兼容</code></li>
<li>document.documentElement 获取HTML元素</li>
<li>document.body 获取body元素<br>兼容所有浏览器的获取当前屏幕的宽度的代码document.documentElement.clientWidth||document.body.clientWidth</li>
<li>document.querySelector(“”) <code>IE6-8不兼容，常用于移动端</code></li>
<li>document.querySelectorAll(“”) <code>IE6-8不兼容，常用于移动端</code><h3 id="DOM中的节点和关系属性"><a href="#DOM中的节点和关系属性" class="headerlink" title="DOM中的节点和关系属性"></a>DOM中的节点和关系属性</h3><strong>节点</strong><br>一个页面中的标签、文字、注释……都是节点</li>
<li><code>childNodes</code>获取所有的子节点</li>
<li><code>children</code>获取所有的元素子节点，当ie8有注释时不兼容</li>
<li><code>parentNode</code>获取父亲节点</li>
<li><code>priviousSibling</code>获取哥哥节点</li>
<li><code>nextSibling</code>获取弟弟节点</li>
<li><code>firstChild</code>获取所有节点中的第一个</li>
<li><code>lastChild</code>获取所有节点中的最后一个</li>
<li><code>firstElementChild</code>获取所有节点中的第一个元素子节点<code>IE6-8不兼容</code></li>
<li><code>lastElementChild</code>获取所有节点中的最后一个元素子节点<code>IE6-8不兼容</code></li>
<li><code>priviousElementSibling</code>获取元素哥哥节点<code>IE6-8不兼容</code></li>
<li><code>nextElementSibling</code>获取元素弟弟节点<code>IE6-8不兼容</code><br><strong>js中我们需要掌握的节点类型</strong><br>|节点类型 |nodeType |nodeName|nodeValue|<br>| :——–: | :——–:| :–: | :–: |<br>| 元素节点 | 1 |  大写的标签名  |null|<br>|文本节点|3|#text|文字内容|<br>|注释节点|8|#comment|注释内容|<br>|document|9|#document|null|<br>在标准浏览器下，我们把空格和回车都当作文本节点处理<h3 id="怎么写完整的注释"><a href="#怎么写完整的注释" class="headerlink" title="怎么写完整的注释"></a>怎么写完整的注释</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">//完整的注释</div><div class="line">/*</div><div class="line"> * getMyChildren</div><div class="line"> * @parameter:</div><div class="line"> *      parameter1:参数<span class="number">1</span></div><div class="line"> *      parameter2：参数<span class="number">2</span></div><div class="line"> * @<span class="keyword">return</span>：</div><div class="line"> *      返回值</div><div class="line"> * by guopengsong on <span class="number">2017</span>/<span class="number">02</span>/<span class="number">08</span></div><div class="line"> */</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="DOM的增删改"><a href="#DOM的增删改" class="headerlink" title="DOM的增删改"></a>DOM的增删改</h3><p><strong>动态创建一个元素标签</strong><br>document.createElement(“div”)创建一个元素标签对象<br>appendChild把元素添加到制定容器的末尾   parent.appendChild(元素)<br>insertBefore把新元素添加到老元素之前,语法parent.insertBerfore(newEle,oldEle)<br><strong>删除元素</strong><br>removeChild:删除元素，语法：parent.removeChild(ele);<br>cloneNode:克隆元素，语法：ele.cloneNode(true/false);如果参数是true，把元素里面的子子孙孙都克隆，默认是false，只克隆当前元素；<br><strong>修改元素</strong><br>replaceChild():替换元素，用新元素替换老元素,语法parent.replaceChild(newEle,oldEle)；</p>
<h3 id="setAttribute"><a href="#setAttribute" class="headerlink" title="setAttribute"></a>setAttribute</h3><p>setAttribute:设置元素的属性，包含自定义属性；<br>setAttribute和打点方式增加自定义属性的区别是：setAttribute设置的属性可以体现在html结构上（修改了html结构），而打点的方式体现不出来，获取时：直接给标签上添加自定义属性，通过”.”获取不到，但是通过getAttribute可以获取到；<br><code>用setAttribute设置的属性，只能用getAttribute获取，也只能用removeAttribute来删除，用打点的方式设置的自定义属性，只能用打点或[&quot;&quot;]的方式获取</code><br><code>IE6-8下setAttribute不能设置class属性，用ele.className=&#39;xxx&#39;</code><br>当一个项目有太多的弹出层的时候，需要动态去创建弹出层；</p>
<h3 id="Math的方法"><a href="#Math的方法" class="headerlink" title="Math的方法"></a>Math的方法</h3><ul>
<li><code>Math.abs()</code>取绝对值</li>
<li><code>Math.ceil()</code>向上取整（碰到小数点就向上进一位） ；Math.ceil(-12.3)的结果是-12；</li>
<li><code>Math.floor()</code>向下取整</li>
<li><code>Math.round()</code>四舍五入；小数点后面的5是一个临界点，正数和负数不一样</li>
<li><p><code>Math.random()</code>取[0-1)之间的随机数，包含0不包含1<br>获取[n-m]之间的随机整数(包含n,m)</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Math.round(Math.random()*(m-n)+n)</div></pre></td></tr></table></figure>
</li>
<li><p><code>Math.max(val1,val2……)</code>取最大值</p>
</li>
<li><code>Math.min(val1,val2……)</code>取最小值<h3 id="字符串方法和应用"><a href="#字符串方法和应用" class="headerlink" title="字符串方法和应用"></a>字符串方法和应用</h3>字符串也有<code>length</code>属性，可以获取字符串的长度，字符串也有所引，从0开始，空格、换行符都属于字符串的字符<br>第一组获取制定字符</li>
<li><code>chartAt(索引)</code>获取指定索引位置的字符</li>
<li><code>chartCodeAt(索引)</code>获取指定索引位置的字符所对应的ASCII值<br>第二组字符串截取</li>
<li><code>substr(n,m)</code>从索引n开始截取m个字符</li>
<li><code>substring(n,m)</code>从索引n开始找到索引m处（不包含m），将找到的字符返回</li>
<li><code>slice(n,m)</code>从索引n开始找到索引m处（不包含m），将找到的字符返回<code>支持负数作为索引</code><br><code>这三个方法如果只写了一个n，不写m，代表截取到末尾</code><br>第三组查找字符的索引</li>
<li><code>indexOf(字符)</code>获取指定字符在字符串中第一次出现的索引，如果没有返回-1</li>
<li><code>lastIndexOf(字符)</code>获取指定字符在字符串中第最后一次出现的索引，如果没有返回-1<br>第四组大小写转换</li>
<li><code>toLowerCase()</code>将字母转化成小写</li>
<li><code>toUpperCase()</code>将字母转化成大写<br>第五组替换</li>
<li><code>replace(老字符，新字符)</code>在不使用正则的情况下，每一次调用这个方法只能替换一次，一般用正则处理<br>第六组将数组按照指定分隔符拆分成数组</li>
<li><code>split(分隔符)</code><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var str=<span class="string">"1+2+3+4"</span>;</div><div class="line">console.log(str.split(<span class="string">'+'</span>));//[<span class="string">"1"</span>, <span class="string">"2"</span>, <span class="string">"3"</span>, <span class="string">"4"</span>]</div><div class="line">console.log(str.split(<span class="string">""</span>));//[<span class="string">"1"</span>, <span class="string">"+"</span>, <span class="string">"2"</span>, <span class="string">"+"</span>, <span class="string">"3"</span>, <span class="string">"+"</span>, <span class="string">"4"</span>]</div><div class="line">console.log(str.split());//[<span class="string">"1+2+3+4"</span>]</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="Date"><a href="#Date" class="headerlink" title="Date"></a>Date</h3><p>获取自己电脑的时间new Date();可以传参数，例如：<br>var time=new Date(“2017-02-11 15:00:00”);但是对字符串的格式有要求，中间用”-“的不行，在<code>IE6-8下不兼容</code>需要改成”/“<br>限时抢购用ajax获取服务器的响应头；<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">var time=new Date();</div><div class="line">var year=time.getFullYear();//获取年</div><div class="line">var month=time.getMonth();//结果是<span class="number">0</span><span class="number">-11</span>的数字，还需要+<span class="number">1</span>才是月份</div><div class="line">var day=time.getDate();//获取日</div><div class="line">var week=time.getDay();//获取周几，<span class="number">0</span><span class="number">-6</span>直接的数字，代表周日到周六，外国周日是第一天</div><div class="line">var hour=time.getHours();//获取小时</div><div class="line">var minute=time.getMinutes();//获取分钟</div><div class="line">var second=time.getSeconds();//获取秒</div><div class="line">var milliSeconds=time.getMilliseconds();//获取毫秒</div><div class="line">var newTime=time.getTime();//获取距离<span class="number">1970</span>年<span class="number">1</span>月<span class="number">1</span>日<span class="number">0</span>时的毫秒数</div></pre></td></tr></table></figure></p>
<h3 id="定时器原理和应用"><a href="#定时器原理和应用" class="headerlink" title="定时器原理和应用"></a>定时器原理和应用</h3><p><strong>setInterval(function,time)</strong>和<strong>setTimeout(function,time)</strong>都是定时器，setInterval是每隔一定的时间执行一次，setTimeout是到达指定时间执行一次，然后就停止；<br>定时器的返回值是一个数字，代表的是第几个定时器。<br>清楚定时器用clearInterval(定时器的返回值)或者clearTimeout(定时器的返回值);</p>
<p>###深入理解引用数据类型<br>在刚开始加载页面的时候，浏览器天生自带一个供js代码执行的环境，我们把这个环境称为”栈内存“也叫作用域，最开始加载页面的时候的作用域叫全局作用域，就是window；<br><code>栈内存是用来存储基本数据类型和从上到下执行js代码，堆内存是用来存储引用数据类型里面的值的</code></p>
<p>###预解释<br>当开始加载js代码之前，会把<code>当前作用域下</code>带var和function关键字的进行提前的声明和定义，我们把这种机制叫做<code>预解释（变量提升）</code>；<br>在代码执行之前，带var关键字的进行提前声明，带function的提前声明加定义，带代码执行的过程中，遇到函数定义那段代码，直接跳过；<code>只声明不赋值默认值是undefined</code><br>预解释是发生在<code>当前作用域下的</code></p>
<h3 id="git和github"><a href="#git和github" class="headerlink" title="git和github"></a>git和github</h3><p>git的作用：</p>
<ul>
<li>记录历史，回到过去</li>
<li>多终端访问</li>
<li>团队协作<br><strong>常用命令</strong><br>win+r：打开命令行<br>cd：进入哪个文件<br>cd ..：返回上一个文件夹<br>git –version:查看git版本，知道git安装是否成功<br>cls：清空命令行（windows系统下）<br>clear：清空命令行（mac系统下）<br>ls -a:查看git仓库下所有的文件<br>git remote -v:查看所关联的远程仓库<br>git remote rm 仓库名，删除远程仓库的连接</li>
</ul>
<p><strong>git的安装</strong><br><code>建议不要更改安装目录，否则需要重新配置环境变量</code><br>注意下面这张图选择第三项，其他的都直接选择next<br><img src="./gitConfig.png" alt="Alt text"><br><strong>git配置</strong><br>配置git用户名和邮箱<br>git config –global user.name ”你的github用户名”<br>git config –global user.email ”你的github邮箱”<br><code>不配置用户名和邮箱的话无法提交</code><br><strong>关联仓库</strong><br>本地新建一个文件夹<br>git init：初始化本地仓库成为一个git可以管理的仓库<br>新建一个远程仓库，本地仓库关联远程仓库<br>git remote add <strong><code>origin</code></strong> <a href="https://github.com/guoPengSong/test.git红色加粗的字是链接的名称可以是任意名字，一般取名origin">https://github.com/guoPengSong/test.git红色加粗的字是链接的名称可以是任意名字，一般取名origin</a><br><strong>提交代码</strong><br>git add -A ：提交到本地仓库<br>git commit -m”这是测试内容”  ：添加注释<br>git push origin master ：提交到远程仓库</p>
<h3 id="学员更新老师讲义地址"><a href="#学员更新老师讲义地址" class="headerlink" title="学员更新老师讲义地址"></a>学员更新老师讲义地址</h3><p>1、进入到老师的仓库，然后fork（将老师的仓库复制一份到自己的仓库）<br>2、学员把自己的仓库下载到本地 git clone 讲义地址<br>3、关联老师的仓库git remote add teacher 老师的讲义地址<br>4、git remote update teacher更新老师的通道<br>5、git pull teacher master拉取分支</p>
<h3 id="提交作业"><a href="#提交作业" class="headerlink" title="提交作业"></a>提交作业</h3><p>把fork老师的仓库内写上自己的作业，提交到自己fork的远程仓库，点击new pull request，然后点击create pull request，写上描述，最后点击create pull request，等待老师的合并确认</p>
<h3 id="预解释"><a href="#预解释" class="headerlink" title="预解释"></a>预解释</h3><p>什么是预解释？<br>在当前作用域下，在js代码执行之前，浏览器会对带var和带function关键字的进行提前声明或定义。<br>对于带var关键字的：提前声明，已经声明过的不再重新声明，但是会重新赋值<br>对于带function关键字的：声明+定义（首先开辟一个内存空间，把方法体内容当作<code>字符串</code>存储到这个内存空间，然后把存储空间的地址给方法名）<br><code>函数执行4阶段：
1.形成私有作用域
2.形参赋值
3.预解释
4.代码执行</code><br><strong>上级作用域跟在哪里定义有关跟在哪里执行无关</strong><br><strong>作用域链</strong><br>当函数被调用的时候会形成一个私有作用域，我们看这个私有作用于下是否有某一个变量a，那么该作用域中的a都是私有变量，跟外界没有任何关系，如果没有私有变量a，那么到上级作用域进行查找，如果没有继续向上查找，直到window。<br><strong>栈内存和堆内存的区别</strong><br>栈内存提供了一个供js代码执行的环境（里面存放轻量级的数据：基本数据类型的数据）<br>堆内存用来存放引用数据类型<br><strong>私有变量和形参都属于私有变量</strong><br>运算符的优先级<br>算术运算符&gt;比较运算符&gt;逻辑运算符&gt;赋值运算符<br><img src="./yunsuanfu.png" alt="运算符的优先级|center"></p>
<p><strong>内存及内存释放</strong><br>堆内存的释放：让占用内存地址的变量等于null<br>栈内存的释放：私有作用域的释放，一般情况下，函数执行完成后私有作用域就会销毁，有两种情况特殊①函数里面的东西被外面的变量或其他东西占用的时候不销毁<br>②不立即销毁，当函数执行完成的时候，会返回一个函数的定义阶段，这个返回的函数还需要再次调用，只有等所有的函数都调用完成这个大函数才能销毁<br><strong>关于this的总结</strong></p>
<ul>
<li>当元素身上的事件触发的时候，会执行一个函数，函数中的this指向当前这个元素</li>
<li>函数被调用的时候看前面是否有点，如果有点，点前面是谁this就是谁</li>
<li>自执行函数的this永远是window</li>
<li>构造函数中的this是实例<br><strong>封装函数应该考虑的步骤</strong><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">/*</div><div class="line"> * 先列需求：例如获得某一个元素的上一个哥哥节点</div><div class="line"> * 参数：当前元素</div><div class="line"> * 返回值：当前元素的上一个哥哥元素</div><div class="line"> * 封装过程：首先看浏览器是否有原生方法支持这个功能，当浏览器支持的时候，直接使用浏览器的方法，浏览器不支持的时候，自己做兼容处理</div><div class="line"> * 最后通过window.prev把这个函数传递到全局下</div><div class="line"> */</div><div class="line">var oDiv=document.getElementById(<span class="string">"div"</span>);</div><div class="line">(function()&#123;</div><div class="line">    function prev(oDiv)&#123;</div><div class="line">        var pre=oDiv.previousSibling;</div><div class="line">        <span class="keyword">while</span>(pre &amp;&amp; pre.nodeType!==<span class="number">1</span>)&#123;</div><div class="line">            pre=pre.previousSibling;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> pre;</div><div class="line">    &#125;</div><div class="line">    window.prev=prev;</div><div class="line">&#125;)();</div></pre></td></tr></table></figure>
</li>
</ul>
<p>从页面中拿到的内容都是字符串类型；<br><code>++</code>默认会进行数据类型转换<br>尽量多用自定义属性<br><strong>逻辑运算符</strong><br><code>&amp;&amp;</code>前面为真才会走后面<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">//下面这两种写法是一个意思</div><div class="line">var a=<span class="number">2</span>;</div><div class="line"><span class="keyword">if</span>(a)&#123;</div><div class="line">     alert(<span class="number">2</span>);</div><div class="line"> &#125;</div><div class="line"> a &amp;&amp; alert(<span class="number">2</span>);</div></pre></td></tr></table></figure></p>
<p><code>||</code>前面为假才会走后面<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var a=undefined||<span class="number">20</span>;</div><div class="line">alert(a);</div></pre></td></tr></table></figure></p>
<p><strong>if语句的几种写法</strong><br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">var a=2;</div><div class="line">//普通写法</div><div class="line">if(a==2)&#123;</div><div class="line">    alert(2);</div><div class="line">&#125;</div><div class="line">//用&amp;&amp;的写法</div><div class="line">a==2 &amp;&amp; alert(2);</div><div class="line">//if的简写</div><div class="line">if(a==2) alert(2);</div><div class="line">//三元运算符</div><div class="line">a==2 ? alert(2):null;</div></pre></td></tr></table></figure></p>
<h3 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h3><p>对象的特征：属性和方法<br>面向对象思想（oo思想、oop思想）<br>面向对象的特点：</p>
<ol>
<li>封装：对同一个功能的函数，只封装一次，以后再遇到此功能只需要调用即可无需重写，避免了大量冗余代码；低耦合，高内聚</li>
<li>继承：子类继承父类的属性和方法</li>
<li>多态：多种形态；包括重载和重写；js没有严格意义的重载，但是有类似重载的功能，例如传参不同，实现功能不同；重写就是子类重写父类的方法<br>###设计模式<br><strong>单例模式</strong><br>单例模式：把描述同一个对象的属性和方法放在同一个命名空间下，避免全局变量的污染和冲突；<br>单例模式的本质就是普通对象；<br>单例模式就是最简单的模块化开发；<br>单例模式的优点：</li>
</ol>
<ul>
<li>单例模式可以避免全局变量的污染和冲突</li>
<li>单例模式就是最简单的模块化开发：本模块直接的相互调用用this.属性名，不同模块间的相互调用是模块名.属性名</li>
</ul>
<p>单例模式的缺点：</p>
<ul>
<li>当多个对象功能一样，会存在大量冗余代码；解决措施：工厂模式（封装）</li>
</ul>
<p><strong>工厂模式</strong></p>
<ul>
<li>首先创建一个空对象</li>
<li>给对象添加属性和方法</li>
<li>输出已经加工过的对象</li>
</ul>
<p><strong>构造函数模式</strong><br>如果想让工厂模式的调用方式，跟系统的调用方式一样需要做两步</p>
<ol>
<li>首字母大写</li>
<li>添加new，当new了之后系统自动创建一个对象就是this；</li>
</ol>
<p><code>构造函数的小细节</code></p>
<ul>
<li>构造函数中的this都是实例</li>
<li>构造函数中存放的都是私有的属性和方法</li>
<li>实例只跟构造函数中的this.xxx有关，跟var无关</li>
<li>构造函数中，系统默认为我们创建一个实例，并返回一个实例，自己不需要手动返回，如果自己手动返回，返回的是一个基本数据类型的数据，无效；返回的是一个引用数据类型的数据，会覆盖系统返回的实例；</li>
<li>构造函数是实例和类打交道</li>
<li>在new一个实例的时候，如果不需要传参，小括号可以省略</li>
</ul>
<p><code>构造函数模式跟工厂模式的区别</code></p>
<ul>
<li>调用的时候<br>工厂模式：普通的调用<br>构造函数模式：new Person();</li>
<li>函数体内的不同<br>工厂模式：三步，创建对象，加工对象，返回对象<br>构造函数模式：一步，加工对象，系统默认创建对象，返回对象</li>
</ul>
<p><strong>构造函数原型链模式</strong><br>把构造函数中每一个实例都具有的方法和公有的属性，放在构造函数的prototype属性上，让他变成共有的方法；<br>原型链模式的基础知识</p>
<ul>
<li><code>每个函数数据类型（普通函数、构造函数）上都有一个属性叫prototype，prototype是个原型</code></li>
<li><code>prototype上存的都是公有的属性和方法，他天生自带一个属性constructor，指向当前这个构造函数（类）</code></li>
<li><code>每个对象数据类型（普通对象、prototype、实例）上都有一个属性__proto__,指向当前实例所属类的原型（__proto__都指向prototype对象）</code><br><img src="./prototype.png" alt="原型链图|center"></li>
</ul>
<p><strong>Object上的共有方法</strong></p>
<ul>
<li>hasOwnProperty:判断是否为对象的私有属性</li>
<li>obj1.isPrototypeof(obj2):判断obj1是否在obj2的原型链上</li>
<li>propertyIsEnumrable:是否为可枚举属性</li>
</ul>
<p><code>__proto__是原型链，prototype是原型</code><br>查找对象.属性名，先看对象的私有空间是否有，如果有，是私有属性，如果没有通过<strong>proto</strong>往当前实例所属类的原型上找，找到了就是共有属性，如果还找不到继续往上查找，直到找到Object.prototype上，如果还没有则是undefined；</p>
<ul>
<li>在ie浏览器禁止通过<strong>proto</strong>去修改实例上的公有属性和方法；</li>
<li>在所有浏览器下，禁止用户批量修改实例上的公有属性和方法； 但是我们可以通过类.prototype.xxx=function(){}进行一个个的修改,在标准浏览器下有两种方式①实例.<strong>proto</strong>.属性名②类.prototype.属性名</li>
</ul>
<p>链式操作我们关注的是上一步操作完成过后的返回值，返回的是什么就跟什么的方法<br><code>in</code>是判断某个属性是否是对象上的私有属性或公有属性<br><strong>关于call、apply和bind</strong><br>call、apply、binde的区别：<br>①call、apply都是在改完函数的this指向，传完参数后让函数<code>立即执行</code><br>区别：第二个参数不同，call的第二个参数是一个个的传，apply的第二个参数是传的一个数组<br>②bind：属于预处理机制，先把bind前面的函数中this改了，参数传了，然后返回一个修改后的函数，需要的时候，手动执行；不兼容；<br><strong>call继承</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">//call继承的核心原理是是把父类私有的属性和方法都继承给子类私有的（让父类在子类的构造函数中执行，并且通过call改变this关键字）</div><div class="line">	function F()&#123;</div><div class="line">		this.x=<span class="number">100</span>;</div><div class="line">		this.y=<span class="number">200</span>;</div><div class="line">	&#125;</div><div class="line">	F.prototype.getName=function()&#123;</div><div class="line">		</div><div class="line">	&#125;</div><div class="line">	var f=new F;</div><div class="line">	function S()&#123;</div><div class="line">		F.call(this);</div><div class="line">	&#125;</div></pre></td></tr></table></figure></p>
<p><strong>冒充继承</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">//冒充继承的核心原理是把父类私有的和公有的属性和方法都继承给子类私有的（因为只有实例才能即能访问私有属性，又能访问公有属性，所以通过实例）</div><div class="line">	function F()&#123;</div><div class="line">		this.x=<span class="number">100</span>;</div><div class="line">		this.y=<span class="number">200</span>;</div><div class="line">	&#125;</div><div class="line">	F.prototype.getName=function()&#123;</div><div class="line">		</div><div class="line">	&#125;</div><div class="line">	var f=new F;</div><div class="line">	function S()&#123;</div><div class="line">		<span class="keyword">for</span>(var attr <span class="keyword">in</span> f)&#123;</div><div class="line">			this[attr]=f[attr];</div><div class="line">		&#125;</div><div class="line">	&#125;</div></pre></td></tr></table></figure></p>
<p><strong>原型链继承</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">//原型链继承的核心原理是把父类私有的和公有的属性和方法都继承给子类公有的（因为只有实例才能即能访问私有属性，又能访问公有属性，所以通过实例，让子类的prototype是父类的实例）</div><div class="line">function F()&#123;</div><div class="line">	this.x=<span class="number">100</span>;</div><div class="line">this.y=<span class="number">200</span>;</div><div class="line">&#125;</div><div class="line">F.prototype.getName=function()&#123;</div><div class="line">	</div><div class="line">&#125;</div><div class="line">function S()&#123;</div><div class="line">	</div><div class="line">&#125;</div><div class="line">S.prototype=new F;</div><div class="line">S.prototype.constructor=S;</div></pre></td></tr></table></figure></p>
<p><strong>拷贝继承（混合继承）</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">//拷贝继承的核心原理是把父类私有的和公有的属性和方法都继承给子类私有或公有的（就是call继承+extend继承）</div><div class="line">function extend(obj1,obj2)&#123;</div><div class="line">	<span class="keyword">for</span>(var attr <span class="keyword">in</span> obj1)&#123;</div><div class="line">		obj2[attr]=obj1[attr];</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> obj2;</div><div class="line">&#125;</div><div class="line">function F()&#123;</div><div class="line">	this.x=<span class="number">100</span>;</div><div class="line">	this.y=<span class="number">200</span>;</div><div class="line">&#125;</div><div class="line">F.prototype.getName=function()&#123;</div><div class="line">	</div><div class="line">&#125;</div><div class="line">function S()&#123;</div><div class="line">	F.call(this);</div><div class="line">&#125;</div><div class="line">extend(F.prototype,S.prototype);</div></pre></td></tr></table></figure></p>
<p><strong>混合继承（call继承+原型链继承）</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">//这种混合继承有问题，call继承已经把父类的私有属性继承到子类的私有属性，通过原型链继承又把父类私有的继承到了子类的公有属性</div><div class="line">function F()&#123;</div><div class="line">	this.x=<span class="number">100</span>;</div><div class="line">	this.y=<span class="number">200</span>;</div><div class="line">&#125;</div><div class="line">F.prototype.getName=function()&#123;</div><div class="line"></div><div class="line">&#125;</div><div class="line">function S()&#123;</div><div class="line">	F.call(this);</div><div class="line">&#125;</div><div class="line">S.prototype=new F;</div><div class="line">S.prototype.constructor=S;</div></pre></td></tr></table></figure></p>
<p><strong>混合继承（call继承+Object.create()）</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">//通过一个中间类过滤已经继承的公有的</div><div class="line">function F()&#123;</div><div class="line">this.x=<span class="number">100</span>;</div><div class="line">	this.y=<span class="number">200</span>;</div><div class="line">&#125;</div><div class="line">F.prototype.getName=function()&#123;</div><div class="line"></div><div class="line">&#125;</div><div class="line">function S()&#123;</div><div class="line">	F.call(this);</div><div class="line">&#125;</div><div class="line">function  Temp() &#123;</div><div class="line"></div><div class="line">&#125;</div><div class="line">Temp.prototype=F.prototype;</div><div class="line">S.prototype=new Temp();</div><div class="line">S.prototype.constructor=S;</div></pre></td></tr></table></figure></p>
<p><strong>函数的三种角色</strong><br>普通函数、构造函数、对象（也具有普通函数的属性和方法的功能）<br>Function.prototype是个匿名函数，和普通的prorotype的的功能是一样的；<br>Object和Function的关系：<br>① Object instanceof Function =&gt;true//所有的类都是Function的实例<br>② Function instanceof Object =&gt;true//所有的对象都是Object的实例<br>③Object.prototype是 Function.prototype的爹<br>④Object.prototype是 Function.<strong>proto</strong>的爹<br><strong>浏览器异常捕获</strong><br>try catch(e) finally<br>无论是走try还是catch，finally都会执行，一般不用<br>类数组转成数组：Array.prototype.slice.call(arguments)转换arguments的时候完全兼容，转换nodelist的时候ie6-8不兼容<br><strong>求一个数组的最小值</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">/*</div><div class="line"> *求数组的最小值</div><div class="line"> */</div><div class="line"> //排序</div><div class="line">var ary=[<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>];</div><div class="line">ary.sort(function (a,b) &#123;</div><div class="line">	<span class="keyword">return</span> a-b;</div><div class="line">&#125;);</div><div class="line">//假设法</div><div class="line">function min(ary) &#123;</div><div class="line">	var min=ary[<span class="number">0</span>];</div><div class="line">	<span class="keyword">for</span> (var i=<span class="number">1</span>;i&lt;ary.length;i++)&#123;</div><div class="line">	    <span class="keyword">if</span>(ary[i]&lt;min)&#123;</div><div class="line">	        min=ary[i];</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> min;</div><div class="line">&#125;</div><div class="line">//利用数学函数和apply的传参方式</div><div class="line">Math.min.apply(Math,ary);</div><div class="line">//利用eval</div><div class="line">eval(<span class="string">'Math.min('</span>+ary.join()+<span class="string">')'</span>);</div><div class="line">eval(<span class="string">'Math.min('</span>+ary.toString()+<span class="string">')'</span>)</div></pre></td></tr></table></figure></p>
<p><strong>关于自定义属性</strong><br>浏览器加载页面的时候会检查元素的属性，只加载自己认识的属性，不加载自定义属性，所以自定义属性不能直接写在html结构中，只能后期通过js添加<br><strong>DOM映射</strong><br>DOM映射就是html结构跟用js获取的元素集合存在映射关系，两者相互影响，一个改变，另一个也改变<br>a.localeCompare(b);这个方法是汉字排序<br>JSON.parse是把JSON格式的字符串转成JSON格式的对象；<br>JSON.stringify()：把JSON格式的对象转成JSON格式的字符串；<br>eval(‘(‘+json+’)’)这里必须这么写，里面包含括号，不会出问题，用于处理ie7下没有JSON对象的问题，</p>
<h3 id="正则"><a href="#正则" class="headerlink" title="正则"></a>正则</h3><p>正则就是用来操作（匹配、捕获）字符串的一系列规则<br>匹配：test<br>捕获：exec()正则的方法、replace()字符串方法、match()字符串方法<br><code>exec方法</code>是用来正则捕获的，返回一个数组，在没有分组的情况下，正则包含3项，第一项是符合的正则的内容，第二项是索引，第三项是原始字符串，如果有分组，分组从第二个参数开始，数组的最后两项永远都是index和input（原始字符串）<br><code>match方法</code>也是用来正则捕获的，返回一个数组，在不加g的情况下match和exec一样，在有分组的情况下match只能拿到大正则捕获的内容，不能捕获分组的内容<br><code>replace方法</code>有两个参数，第一个参数是字符串/正则，第二个参数是字符串/函数，当第二个参数是一个函数的时候，这个函数的参数是正则捕获到的内容，没匹配成功一次这个匿名函数就会调用一次，用函数的返回值替换这个大正则匹配的内容，也可以匹配分组的内容<br>正则捕获有<code>懒惰性</code>和<code>贪婪性</code><br><code>懒惰性</code>：每次都从头开始只会找一项，因为正则的lastIndex（每次开始查找的位置）不变，解决办法是加修饰符g<br><code>贪婪性</code>：正则尽可能多的匹配，解决办法是在正则的量词元字符后面加?表示非贪婪匹配，每次匹配最少的<br>正则元字符</p>
<table>
<thead>
<tr>
<th style="text-align:center">元字符</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">\</td>
<td style="text-align:center">将下一个字符标记为一个特殊字符、或一个原义字符、或一个后向引用、或一个八进制转义符。例如，’n’ 匹配字符 “n”。’\n’ 匹配一个换行符。序列 ‘\‘ 匹配 “\” 而 “(“ 则匹配 “(“</td>
</tr>
<tr>
<td style="text-align:center">^</td>
<td style="text-align:center">匹配输入字符串的开始位置。如果设置了 RegExp 对象的 Multiline 属性，^ 也匹配 ‘\n’ 或 ‘\r’ 之后的位置。</td>
</tr>
<tr>
<td style="text-align:center">\$</td>
<td style="text-align:center">匹配输入字符串的结束位置。如果设置了RegExp 对象的 Multiline 属性，$ 也匹配 ‘\n’ 或 ‘\r’ 之前的位置。</td>
</tr>
<tr>
<td style="text-align:center">*</td>
<td style="text-align:center">匹配前面的子表达式零次或多次。例如，zo<em> 能匹配 “z” 以及 “zoo”。 </em> 等价于{0,}</td>
</tr>
<tr>
<td style="text-align:center">+</td>
<td style="text-align:center">匹配前面的子表达式一次或多次。例如，’zo+’ 能匹配 “zo” 以及 “zoo”，但不能匹配 “z”。+ 等价于 {1,}</td>
</tr>
<tr>
<td style="text-align:center">?</td>
<td style="text-align:center">匹配前面的子表达式零次或一次。例如，”do(es)?” 可以匹配 “do” 或 “does” 中的”do” 。? 等价于{0,1}</td>
</tr>
<tr>
<td style="text-align:center">{n}</td>
<td style="text-align:center">n 是一个非负整数。匹配确定的 n 次。例如，’o{2}’ 不能匹配 “Bob” 中的 ‘o’，但是能匹配 “food” 中的两个 o</td>
</tr>
<tr>
<td style="text-align:center">{n,}</td>
<td style="text-align:center">n 是一个非负整数。至少匹配n 次。例如，’o{2,}’ 不能匹配 “Bob” 中的 ‘o’，但能匹配 “foooood” 中的所有 o。’o{1,}’ 等价于 ‘o+’。’o{0,}’ 则等价于 ‘o*’</td>
</tr>
<tr>
<td style="text-align:center">{n,m}</td>
<td style="text-align:center">m 和 n 均为非负整数，其中n &lt;= m。最少匹配 n 次且最多匹配 m 次。如， “o{1,3}” 将匹配 “fooooood”中的前三个 o。’o{0,1}’ 等价于 ‘o?’。请注意在逗号和两个数之间不能有空格</td>
</tr>
<tr>
<td style="text-align:center">?</td>
<td style="text-align:center">当该字符紧跟在任何一个其他限制符 (*, +, ?, {n}, {n,}, {n,m}) 后面时，匹配模式是非贪婪的。非贪婪模式尽可能少的匹配所搜索的字符串，而默认的贪婪模式则尽可能多的匹配所搜索的字符串。例如，对于字符串 “oooo”，’o+?’ 将匹配单个 “o”，而 ‘o+’ 将匹配所有 ‘o’</td>
</tr>
<tr>
<td style="text-align:center">.</td>
<td style="text-align:center">匹配除 “\n” 之外的任何单个字符。</td>
</tr>
<tr>
<td style="text-align:center">(pattern)</td>
<td style="text-align:center">匹配pattern 并获取这一匹配。在JScript 中则使用 \$1…\$9 属性。要匹配圆括号字符，请使用 ‘\(‘ 或’\)’</td>
</tr>
<tr>
<td style="text-align:center">(?:pattern)</td>
<td style="text-align:center">匹配 pattern 但不获取匹配结果，也就是说这是一个非获取匹配，不进行存储供以后使用。这在使用”或” 字符 (\</td>
<td>) 来组合一个模式的各个部分是很有用。例如， ‘industr(?:y\</td>
<td>ies) 就是一个比’industry\</td>
<td>industries’ 更简略的表达式</td>
</tr>
<tr>
<td style="text-align:center">(?=pattern)</td>
<td style="text-align:center">正向预查，在任何匹配 pattern 的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如， ‘Windows (?=95\</td>
<td>98\</td>
<td>NT\</td>
<td>2000)’ 能匹配 “Windows 2000” 中的”Windows” ，但不能匹配 “Windows 3.1” 中的 “Windows”。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始</td>
</tr>
<tr>
<td style="text-align:center">(?!pattern)</td>
<td style="text-align:center">负向预查，在任何不匹配的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如’Windows (?!95\</td>
<td>98\</td>
<td>NT\</td>
<td>2000)’ 能匹配 “Windows 3.1” 中的 “Windows”，但不能匹配 “Windows 2000” 中的 “Windows”。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始</td>
</tr>
<tr>
<td style="text-align:center">x\</td>
<td style="text-align:center">y</td>
<td>匹配 x 或 y。例如，’z\</td>
<td>food’ 能匹配 “z” 或 “food”。’(z\</td>
<td>f)ood’ 则匹配 “zood” 或 “food”</td>
</tr>
<tr>
<td style="text-align:center">[xyz]</td>
<td style="text-align:center">字符集合。匹配所包含的任意一个字符。例如， ‘[abc]’ 可以匹配 “plain” 中的 ‘a’</td>
</tr>
<tr>
<td style="text-align:center">[^xyz]</td>
<td style="text-align:center">负值字符集合。匹配未包含的任意字符。例如， ‘[^abc]’ 可以匹配 “plain” 中的’p’</td>
</tr>
<tr>
<td style="text-align:center">[a-z]</td>
<td style="text-align:center">字符范围。匹配指定范围内的任意字符。例如，’[a-z]’ 可以匹配 ‘a’ 到 ‘z’ 范围内的任意小写字母字符。例如:[a-z]   [A-Z]   [0-9]</td>
</tr>
<tr>
<td style="text-align:center">[^a-z]</td>
<td style="text-align:center">负值字符范围。匹配任何不在指定范围内的任意字符。例如，’[^a-z]’ 可以匹配任何不在 ‘a’ 到 ‘z’ 范围内的任意字符</td>
</tr>
<tr>
<td style="text-align:center">\b</td>
<td style="text-align:center">匹配一个单词边界，也就是指单词和空格间的位置。例如， ‘er\b’ 可以匹配”never” 中的 ‘er’，但不能匹配 “verb” 中的 ‘er’</td>
</tr>
<tr>
<td style="text-align:center">\B</td>
<td style="text-align:center">匹配非单词边界。’er\B’ 能匹配 “verb” 中的 ‘er’，但不能匹配 “never” 中的 ‘er’</td>
</tr>
<tr>
<td style="text-align:center">\cx</td>
<td style="text-align:center">匹配由x指明的控制字符。例如， \cM 匹配一个 Control-M 或回车符。 x 的值必须为 A-Z 或 a-z 之一。否则，将 c 视为一个原义的 ‘c’ 字符</td>
</tr>
<tr>
<td style="text-align:center">\d</td>
<td style="text-align:center">匹配一个数字字符。等价于 [0-9]。</td>
</tr>
<tr>
<td style="text-align:center">\D</td>
<td style="text-align:center">匹配一个非数字字符。等价于 [^0-9]</td>
</tr>
<tr>
<td style="text-align:center">\f</td>
<td style="text-align:center">匹配一个换页符。等价于 \x0c 和 \cL</td>
</tr>
<tr>
<td style="text-align:center">\n</td>
<td style="text-align:center">匹配一个换行符。等价于 \x0a 和 \cJ</td>
</tr>
<tr>
<td style="text-align:center">\r</td>
<td style="text-align:center">匹配一个回车符。等价于 \x0d 和 \cM</td>
</tr>
<tr>
<td style="text-align:center">\s</td>
<td style="text-align:center">匹配任何空白字符，包括空格、制表符、换页符等等。等价于 [ \f\n\r\t\v]</td>
</tr>
<tr>
<td style="text-align:center">\S</td>
<td style="text-align:center">匹配任何非空白字符。等价于 [^ \f\n\r\t\v]</td>
</tr>
<tr>
<td style="text-align:center">\t</td>
<td style="text-align:center">匹配一个制表符。等价于 \x09 和 \cI</td>
</tr>
<tr>
<td style="text-align:center">\v</td>
<td style="text-align:center">匹配一个垂直制表符。等价于 \x0b 和 \cK</td>
</tr>
<tr>
<td style="text-align:center">\w</td>
<td style="text-align:center">匹配包括数字、字母、下划线的任何单词字符。等价于’[A-Za-z0-9_]’</td>
</tr>
<tr>
<td style="text-align:center">\W</td>
<td style="text-align:center">匹配任何非单词字符。等价于 ‘[^A-Za-z0-9_]’</td>
</tr>
<tr>
<td style="text-align:center">\xn</td>
<td style="text-align:center">匹配 n，其中 n 为十六进制转义值。十六进制转义值必须为确定的两个数字长。例如， ‘\x41’ 匹配”A”。’\x041’ 则等价于 ‘\x04’ &amp; “1”。正则表达式中可以使用 ASCII 编码</td>
</tr>
<tr>
<td style="text-align:center">\num</td>
<td style="text-align:center">匹配 num，其中 num 是一个正整数。对所获取的匹配的引用。例如，’(.)\1’ 匹配两个连续的相同字符</td>
</tr>
<tr>
<td style="text-align:center">\n</td>
<td style="text-align:center">标识一个八进制转义值或一个后向引用。如果 \n 之前至少 n 个获取的子表达式，则 n 为后向引用。否则，如果 n 为八进制数字 (0-7)，则 n 为一个八进制转义值</td>
</tr>
<tr>
<td style="text-align:center">\nm</td>
<td style="text-align:center">标识一个八进制转义值或一个后向引用。如果 \nm 之前至少有is preceded by at least nm 个获取得子表达式，则 nm 为后向引用。如果 \nm 之前至少有 n 个获取，则 n 为一个后跟文字 m 的后向引用。如果前面的条件都不满足，若  n 和 m 均为八进制数字 (0-7)，则 \nm 将匹配八进制转义值 nm</td>
</tr>
<tr>
<td style="text-align:center">\nml</td>
<td style="text-align:center">如果 n 为八进制数字 (0-3)，且 m 和 l 均为八进制数字 (0-7)，则匹配八进制转义值 nml</td>
</tr>
<tr>
<td style="text-align:center">\un</td>
<td style="text-align:center">匹配 n，其中 n 是一个用四个十六进制数字表示的 Unicode 字符。例如， \u00A9 匹配版权符号 (?)</td>
</tr>
</tbody>
</table>
<p>修饰符：<br>g：全局匹配<br> i ：忽略大小写<br>m：换行<br>字面量创建的正则无法使用变量，可以选择实例创建的方式，但是实例创建需要转译<br><code>[]</code>中的+.没有特殊含义，不需要转译<br><code>[]</code>中没有两位数<br><code>(?:)</code>匹配不捕获分组的内容<br>当//中遇到|的时候最好用()包起来，提高优先级<br><strong>常用正则</strong>   </p>
<ul>
<li>手机号正则     /^1\d{10}$/</li>
<li>有效数字正则    /^[+-]?(\d|([1-9]\d+))(.\d+)?$/</li>
<li>验证年龄 18-65  /^((18|19)|([2-5]\d)|(6[0-5]))$/</li>
<li>验证邮箱的正则   /^([\w.-]+)@([0-9a-zA-Z]+)(.[a-zA-Z]{2,4}){1,2}$/</li>
<li>中文名字  /^[\u4e00-\u9fa5]{2,4}$/</li>
<li>身份证号<br>var reg = /^\d{17}(\d|X)\$/;<br>var reg = /^(\d{2})(\d{4})(\d{4})(\d{2})(\d{2})(\d{2})(\d)(\d|X)$/;</li>
<li>非空验证 !/^\s*$/</li>
<li>去除首尾空格 /(^ +)|( +$)/g</li>
<li>偷小说 /&lt;[^&lt;&gt;]&gt;/g; 注意：textarea 千万不要通过innerHTML取值，因为你拿不到，只能通过value才能内容；</li>
<li>queryURLParameter 获取地址栏中的参数<br>var str=’<a href="http://image.baidu.com/search/index?tn=baiduimage&amp;ipn=r&amp;ct=201326592&amp;cl=2&amp;lm=-1&amp;st=-1&amp;fm=result&amp;fr=&amp;sf=1&amp;fmq=1462967508128_R&amp;pv=&amp;ic=0&amp;nc=1&amp;z=&amp;se=1&amp;showtab=0&amp;fb=0&amp;width=&amp;height=&amp;face=0&amp;istype=2&amp;ie=utf-8&amp;word=%E5%88%98%E8%AF%97%E8%AF%97" target="_blank" rel="external">http://image.baidu.com/search/index?tn=baiduimage&amp;ipn=r&amp;ct=201326592&amp;cl=2&amp;lm=-1&amp;st=-1&amp;fm=result&amp;fr=&amp;sf=1&amp;fmq=1462967508128_R&amp;pv=&amp;ic=0&amp;nc=1&amp;z=&amp;se=1&amp;showtab=0&amp;fb=0&amp;width=&amp;height=&amp;face=0&amp;istype=2&amp;ie=utf-8&amp;word=%E5%88%98%E8%AF%97%E8%AF%97</a>‘<br>var reg=/(([^?&amp;=]+)=([^?&amp;=]+))/g;</li>
</ul>
<p>回调函数：回调函数就是把函数当作参数传给另一个函数<br>forEach：用于遍历数组，没有返回值，有两个参数，第一个参数是回调函数，第二个参数是可选的，是改变函数this指向，数组有几项回调函数就被调用几次，回调函数默认this是window，回调函数被传了3个参数，第一个参数是数组当前项，第二个参数是当前项的索引，第三个参数是原始数组<code>IE6-8不兼容</code><br>map：也是用于遍历数组，跟forEach用法一样，但是map方法有返回值，返回值是回掉函数的返回值的集合；</p>
<h3 id="js盒子模型"><a href="#js盒子模型" class="headerlink" title="js盒子模型"></a>js盒子模型</h3><p><strong>client系列</strong></p>
<ul>
<li>clientHeight:  内容高度不包含边框  内容+上下填充   content+padding</li>
<li>clientWidth：  内容+左右填充    content+padding</li>
<li>clientTop: 上边框的宽度</li>
<li>clientLeft:  左边框的宽度</li>
</ul>
<p><strong>offset系列</strong></p>
<ul>
<li>offsetHeight:  clientHeight+上下边框</li>
<li>offsetWidth:   clientWidth+左右边框 </li>
<li>offsetLeft:  外边框距离offsetParent的内边框的左偏移量,IE8的offsetleft包含定位父级的边框</li>
<li>offsetTop:   外边框距离offsetParent的内边框的上偏移量</li>
<li>offsetParent: 父级参照物，如果包含自己的父元素有定位属性那么offsetParent就是自己的parentNode，如果自己的父元素节点没有定位属性，那么就去父元素的父元素去查找定位属性，如果有offsetParent就是这个。如果没有会继续向上查找，一直到body。如果还没有定位属性那么offsetParent就是默认body了.</li>
<li><code>ps: offsetLeft和offsetTop的值要取决于offsetParent是谁
ps: offsetParent对上一级元素的定位属性是有要求的，只有absolute,relative,fixed才可以
ps: document.body.offsetParent = null
ps: document.parentNode = null</code></li>
</ul>
<p><strong>scroll系列</strong></p>
<ul>
<li>scrollWidth:  如果没有溢出那么和clientWidth是相等的，如果有溢出那么（约等于）是左填充+内容宽度  padding-left + content</li>
<li>scrollHeight: 如果没有溢出和clientHeight是相等的，如果有溢出那么就是（约等于）上填充+内容高度</li>
<li>scrollTop: 已经滚出去的高度  赋值最小就是0</li>
<li>scrollLeft: 已经滚出去的宽度</li>
<li><code>ps: 在所有盒子模型的属性中，只有scrollTop和scrollLeft可以被重新赋值</code></li>
</ul>
<p><strong>关于js盒子模型的小问题</strong><br>以上属性，只能拿到整数，无法获取小数（四舍五入）；–不解决（无法解决）<br><strong>浏览器获取非行内样式</strong><br>标准浏览器：getComputedStyle(oDiv,null).height<br>ie6-8：oDiv.currentStyle.height<br><strong>关于浏览器的兼容处理</strong></p>
<ul>
<li>try…catch….</li>
<li>属性判断:三种方法</li>
</ul>
<ol>
<li>attr in obj  <strong>*</strong>他最常用；</li>
<li>obj.attr</li>
<li>typeof obj.attr === ‘function’</li>
</ol>
<ul>
<li>浏览器判断var re=/MSIE (6|7|8)/</li>
</ul>
<ol>
<li>window.navigator.userAgent.match(re)  拿到[] 拿不到null</li>
<li>window.navigator.userAgent.search(re) 拿到：索引 拿不到：-1</li>
<li>re.test(window.navigator.userAgent)  拿到：true 拿不到：false</li>
<li>re.exec(window.navigator.userAgent) 拿到[] 拿不到null<br><strong>判断是否传参的三种方式</strong></li>
</ol>
<ul>
<li>定义形参没有赋值拿到的是undefined，判断形参是不是undefined；</li>
<li>typeof 形参===”undefined”这里一定要加引号</li>
<li>判断arguments.length</li>
<li>最好不要用if(形参)，如果传0会出问题</li>
</ul>
<p>在结构父级中最大的元素是html元素，最大的节点是document节点，在定位父级最大的元素是body元素</p>
<h3 id="绑定数据的方式"><a href="#绑定数据的方式" class="headerlink" title="绑定数据的方式"></a>绑定数据的方式</h3><ul>
<li>字符串拼接（最常用，用<code>转义字符\</code>解决报错问题）</li>
<li>元素创建（每次插入都会引起回流）</li>
<li>文档碎片（先放入文档碎片，最后统一插入，最后要释放文档碎片）<h3 id="跑马灯效果的核心"><a href="#跑马灯效果的核心" class="headerlink" title="跑马灯效果的核心"></a>跑马灯效果的核心</h3>利用div、ul、li布局，div的宽度是ul的宽度，核心是先复制一份一模一样的li在原来的li的后面，改变ul的left值，当left值小于ul的宽度的一半的时候，让ul的left值为0；<br>###图片延迟加载的核心<br>利用div、img布局，div的背景图是默认图片，先把真正要引入的图片放在img的自定义属性上，当滚轮卷去的高度加屏幕的高度大于图片距离文档的高度的时候，创建一个img实例，让这个实例的src属性等于自定义属性的路径，当图片加载完成后（onload），让图片的src属性等于真实图片路径，img的实例为null，还需要避免重复加载（判断是否loaded）；<h3 id="瀑布流的核心"><a href="#瀑布流的核心" class="headerlink" title="瀑布流的核心"></a>瀑布流的核心</h3>利用ul、li布局，ul浮动，先判断哪个ul高度最小，把图片插入那个ulxi<h3 id="运动"><a href="#运动" class="headerlink" title="运动"></a>运动</h3><strong>运动的三种方式</strong></li>
<li>固定步长</li>
<li>固定时间，根据时间求出步长</li>
<li>利用Linear公示<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">/*</div><div class="line"> *Linear公式的目的是为了求出最新位置</div><div class="line"> *参数：t:已经运动的时间；b:运动起始点；c:要运动的路程；d:运动的总时间；</div><div class="line"> *</div><div class="line"> */</div><div class="line">function(t,b,c,d)&#123;</div><div class="line">	return c/d*t+b</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>用递归调用move函数，当匿名函数中的东西被外面占用的时候，会形成无数个不销毁的私有作用域；解决措施，不要这个参数；在套一层_move函数来解决；<br><strong>轮播图布局</strong><br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">//HTML部分</div><div class="line">&lt;div id="box"&gt;</div><div class="line">    &lt;ul&gt;</div><div class="line">        &lt;li&gt;&lt;/li&gt;</div><div class="line">        &lt;li&gt;&lt;/li&gt;</div><div class="line">        &lt;li&gt;&lt;/li&gt;</div><div class="line">    &lt;/ul&gt;</div><div class="line">&lt;/div&gt;</div></pre></td></tr></table></figure></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">//css部分</div><div class="line">#box&#123;</div><div class="line">    width: 500px;</div><div class="line">    height:300px;</div><div class="line">    overflow: hidden;</div><div class="line">    position: relative;</div><div class="line">&#125;</div><div class="line">ul,li&#123;</div><div class="line">    list-style: none;</div><div class="line">&#125;</div><div class="line">ul&#123;</div><div class="line">    width: 1500px;</div><div class="line">    height: 300px;</div><div class="line">    position: absolute;</div><div class="line">    left: 0;</div><div class="line">    top: 0;</div><div class="line">&#125;</div><div class="line">li&#123;</div><div class="line">    width: 500px;</div><div class="line">    height: 300px;</div><div class="line">    float: left;</div><div class="line">&#125;</div><div class="line">li:nth-child(1)&#123;</div><div class="line">    background: pink;</div><div class="line">&#125;</div><div class="line">li:nth-child(2)&#123;</div><div class="line">    background: yellow;</div><div class="line">&#125;</div><div class="line">li:nth-child(3)&#123;</div><div class="line">    background: red;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>普通函数封装改成面向对象封装：</strong><br>1）全局变量变成私有属性–构造函数<br>2）全局函数变成公有方法–原型上<br>3）init：实际就是我们所有函数的顺序调用；<br>4）随时注意this的变化</p>
<h3 id="jQuery"><a href="#jQuery" class="headerlink" title="jQuery"></a>jQuery</h3><p>只要以\$为对象调用的都是工具类方法，例如\$.ajax();<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">$.ajax(&#123;</div><div class="line">    type:'GET',</div><div class="line">    url:'www.baidu.com',</div><div class="line">    dataType:'json'//返回的数据类型,</div><div class="line">    async:false,//是否异步</div><div class="line">    cache:false,//是否缓存</div><div class="line">    data:form.serialize(),//表单序列化</div><div class="line">    success:function(val)&#123;//成功之后返回数据</div><div class="line">    &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<ul>
<li>form.serialize() 表单序列化，用于前端向后台传参 ## 插件封装 extend({})</li>
<li>$.fn.extend({}) 给原型上扩充方法–实例使用</li>
<li>$.extend({}) 给类上扩充静态方法；–类自身使用，因为这是类的私有属性</li>
</ul>
<h3 id="jQuery-1"><a href="#jQuery-1" class="headerlink" title="jQuery"></a>jQuery</h3><p>jQuery对象转成原生对象：\$(“div”).get(0),或者\$(“div”)[0];<br>jQuery创建元素：\$(“&lt; div&gt;&lt; /div&gt;”);<br>jQuery的插件扩充：$.fn.extend({}) 给原型上扩充方法–实例使用，\$.extend({}) 给类上扩充静态方法；–类自身使用，因为这是类的私有属性；<br>form.serialize() 表单序列化，用于前端向后台传参,把表单中的数据拼接，中间用&amp;符号连接起来</p>
<h3 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h3><p><strong>事件都包含哪些：</strong></p>
<ul>
<li>鼠标事件：onclick  ondbclick onmouseover onmouseout onmouseenter onmouseleave oncontextmenu …</li>
<li>系统事件：onload onscroll onerror onresize…</li>
<li>键盘事件：onkeydown onkeyup onkeypress…</li>
<li>表单事件：onfocus onblur …</li>
</ul>
<p><strong>DOM0级事件和DOM二级事件的区别：</strong><br>1）DOM0级事件是元素身上的私有属性 2）DOM0级事件，当给同一个元素，同一个行为上绑定多个不同的方法的时候，后面的方法会“覆盖”前面的方法；<br>1）DOM2级事件是元素身上的公有属性，存放在元素所属的eventTarget这个类的原型上；2）DOM2级事件，可以给同一个元素的同一个行为上绑定多个不同的方法；<br><strong>事件对象：就是描述了当前所触发行为的详细信息；</strong></p>
<ul>
<li>标准浏览器下，通过形参e来得到事件对象</li>
<li>IE6-8下的事件对象，跟形参没有任何关系；通过window.event来获取<br>兼容处理：e=e||window.event;</li>
</ul>
<p><strong>关于事件对象的详细信息：</strong></p>
<ul>
<li>clientX/clientY:当前鼠标落脚点距离可视区左上角的坐标位置；–兼容</li>
<li>pageX/pageY:当前鼠标落脚点距离第一屏左上角的坐标位置；–不兼容；（clientY+scrollTop处理兼容）</li>
<li>事件源e.target：当前发生事件的这个元素–不兼容<br>兼容处理：e.target||e.srcElement;</li>
<li>keyCode:键盘的键码；</li>
<li>阻止默认事件:e.preventDefault? e.preventDefault(): e.returnValue=false;</li>
<li>阻止事件冒泡：e.stopPropagation?e.stopPropagation():e.cancelBubble=true;</li>
<li>事件流：<br>1）事件流包含两阶段：①捕获阶段（从外向里） ②冒泡阶段（从里向外）<br>2）事件流包含三阶段：①捕获阶段 ②事件源 e.target ③冒泡阶段<br><code>注意：顺序问题=》先捕获再冒泡；DOM0级事件只有冒泡阶段，捕获和冒泡只走一次</code></li>
<li>onmouseover和onmouseout有事件冒泡的问题，用onmouseenter和onmouseleave解决</li>
</ul>
<h3 id="放大镜效果原理"><a href="#放大镜效果原理" class="headerlink" title="放大镜效果原理"></a>放大镜效果原理</h3><p>一张小图片，小图片那里有一个等比例的遮罩层，一张等比例的大图片默认隐藏放在同小图片一样大的盒子里，小图片onmouseenter的时候，让遮罩层和大图片显示，onmousemove的时候按照比例计算大图片要移动的距离，还要注意判断边界值，onmouseleave的时候遮罩层和大图隐藏</p>
<h3 id="拉勾网穿墙效果原理"><a href="#拉勾网穿墙效果原理" class="headerlink" title="拉勾网穿墙效果原理"></a>拉勾网穿墙效果原理</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">//先判断鼠标是从哪个方向进来的</div><div class="line">function hoverDir(e)&#123;</div><div class="line">    var x=oDiv.offsetWidth/<span class="number">2</span>+oDiv.offsetLeft- e.clientX;</div><div class="line">    var y=oDiv.offsetHeight/<span class="number">2</span>+oDiv.offsetTop- e.clientY;</div><div class="line">    <span class="keyword">return</span> Math.round((Math.atan2(y,x)*<span class="number">180</span>/Math.PI+<span class="number">180</span>)/<span class="number">90</span>)%<span class="number">4</span>;</div><div class="line">    //<span class="number">1.</span>求弧度</div><div class="line">    //<span class="number">2.</span>弧度转度</div><div class="line">&#125;</div><div class="line">oDiv.onmouseover=function(e)&#123;</div><div class="line">    e=e||window.event;</div><div class="line">    //解决onmouseover的冒泡问题</div><div class="line">    var oTo= e.relatedTarget|| e.fromElement;</div><div class="line">    <span class="keyword">if</span>(this.contains(oTo)) <span class="keyword">return</span>;</div><div class="line">    var con=hoverDir(e);</div><div class="line">    //当鼠标移入的时候，让物体迅速的移到起始位置，然后，运动的移动到<span class="number">0</span>,<span class="number">0</span>位置；</div><div class="line">    switch(con)&#123;</div><div class="line">        case <span class="number">0</span>://right</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        case <span class="number">1</span>://bottom</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        case <span class="number">2</span>://left</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        default://top</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="………"><a href="#………" class="headerlink" title="……….."></a>………..</h3><h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><p>属性不会报错，变量会报错，原型链不报错，作用域链报错，作用域链是找变量，原型链是找属性<br>toFixed(要保留的小数位数)，四舍五入的保留小数点<br>逗号只能走一个<br>oDiv代表一个元素，aDiv代表一组元素，jQuery变量前缀加$</p>
  
	</div>
		<footer class="article-footer clearfix">




<div class="article-share" id="share">

  <div data-url="https://github.com/guoPengSong/2017/04/16/javascript/" data-title="javascript笔记 | guopengsong" data-tsina="15076687250" class="share clearfix">
  </div>

</div>
</footer>   	       
	</article>
	
<nav class="article-nav clearfix">
 
 <div class="prev" >
 <a href="/2017/04/16/hello-world/" title="Hello World">
  <strong>PREVIOUS:</strong><br/>
  <span>
  Hello World</span>
</a>
</div>


<div class="next">
<a href="/2017/04/16/shell/"  title="基本shell命令的使用">
 <strong>NEXT:</strong><br/> 
 <span>基本shell命令的使用
</span>
</a>
</div>

</nav>

	


</div>  
      <div class="openaside"><a class="navbutton" href="#" title="显示侧边栏"></a></div>

  <div id="toc" class="toc-aside">
  <strong class="toc-title">文章目录</strong>
  <ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#css引入入到页面的几种方式"><span class="toc-number">1.</span> <span class="toc-text">css引入入到页面的几种方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#js引入到页面中的几种方式"><span class="toc-number">2.</span> <span class="toc-text">js引入到页面中的几种方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#js中常用的几种输出方式和控制台详解"><span class="toc-number">3.</span> <span class="toc-text">js中常用的几种输出方式和控制台详解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#js的组成和命名规范"><span class="toc-number">4.</span> <span class="toc-text">js的组成和命名规范</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#js中的变量和数据类型以及数据类型之间的转化"><span class="toc-number">5.</span> <span class="toc-text">js中的变量和数据类型以及数据类型之间的转化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#js中的判断的应用（开关灯）"><span class="toc-number">6.</span> <span class="toc-text">js中的判断的应用（开关灯）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#js中的三个循环"><span class="toc-number">7.</span> <span class="toc-text">js中的三个循环</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#js中隔行变色的原理"><span class="toc-number">8.</span> <span class="toc-text">js中隔行变色的原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#九九乘法表"><span class="toc-number">9.</span> <span class="toc-text">九九乘法表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#数组和数组的常用方法"><span class="toc-number">10.</span> <span class="toc-text">数组和数组的常用方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#冒泡排序"><span class="toc-number">11.</span> <span class="toc-text">冒泡排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#数组去重"><span class="toc-number">12.</span> <span class="toc-text">数组去重</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DOM获取元素的方法（8个）"><span class="toc-number">13.</span> <span class="toc-text">DOM获取元素的方法（8个）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DOM中的节点和关系属性"><span class="toc-number">14.</span> <span class="toc-text">DOM中的节点和关系属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#怎么写完整的注释"><span class="toc-number">15.</span> <span class="toc-text">怎么写完整的注释</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DOM的增删改"><span class="toc-number">16.</span> <span class="toc-text">DOM的增删改</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#setAttribute"><span class="toc-number">17.</span> <span class="toc-text">setAttribute</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Math的方法"><span class="toc-number">18.</span> <span class="toc-text">Math的方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#字符串方法和应用"><span class="toc-number">19.</span> <span class="toc-text">字符串方法和应用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Date"><span class="toc-number">20.</span> <span class="toc-text">Date</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#定时器原理和应用"><span class="toc-number">21.</span> <span class="toc-text">定时器原理和应用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#git和github"><span class="toc-number">22.</span> <span class="toc-text">git和github</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#学员更新老师讲义地址"><span class="toc-number">23.</span> <span class="toc-text">学员更新老师讲义地址</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#提交作业"><span class="toc-number">24.</span> <span class="toc-text">提交作业</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#预解释"><span class="toc-number">25.</span> <span class="toc-text">预解释</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#面向对象"><span class="toc-number">26.</span> <span class="toc-text">面向对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#正则"><span class="toc-number">27.</span> <span class="toc-text">正则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#js盒子模型"><span class="toc-number">28.</span> <span class="toc-text">js盒子模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#绑定数据的方式"><span class="toc-number">29.</span> <span class="toc-text">绑定数据的方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#跑马灯效果的核心"><span class="toc-number">30.</span> <span class="toc-text">跑马灯效果的核心</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#瀑布流的核心"><span class="toc-number">31.</span> <span class="toc-text">瀑布流的核心</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#运动"><span class="toc-number">32.</span> <span class="toc-text">运动</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#jQuery"><span class="toc-number">33.</span> <span class="toc-text">jQuery</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#jQuery-1"><span class="toc-number">34.</span> <span class="toc-text">jQuery</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#事件"><span class="toc-number">35.</span> <span class="toc-text">事件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#放大镜效果原理"><span class="toc-number">36.</span> <span class="toc-text">放大镜效果原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#拉勾网穿墙效果原理"><span class="toc-number">37.</span> <span class="toc-text">拉勾网穿墙效果原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#………"><span class="toc-number">38.</span> <span class="toc-text">………..</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#附录"><span class="toc-number"></span> <span class="toc-text">附录</span></a>
  </div>

<div id="asidepart">
<div class="closeaside"><a class="closebutton" href="#" title="隐藏侧边栏"></a></div>
<aside class="clearfix">

  

  

  <div class="rsspart">
	<a href="null" target="_blank" title="rss">RSS 订阅</a>
</div>

</aside>
</div>
    </div>
    <footer><div id="footer" >
	
	<div class="line">
		<span></span>
		<div class="author"></div>
	</div>
	
	
	<section class="info">
		<p> 大家好，我是郭鹏松 <br/>
			这是我的博客，欢迎大家一起讨论javascript</p>
	</section>
	 
	<div class="social-font" class="clearfix">
		
		<a href="http://weibo.com/15076687250" target="_blank" name="weibo"></a>
		
		
		
		<a href="https://github.com/guoPengSong" target="_blank" name="github"></a>
		
		
	</div>
		<p class="copyright">Powered by <a href="http://hexo.io" target="_blank" title="hexo">hexo</a> and Theme by <a href="https://github.com/zhyu/yaht" target="_blank" title="YAHT">YAHT</a> © 2017 
		
		<a href="https://github.com/guoPengSong" target="_blank" title="郭鹏松">郭鹏松</a>
		
		</p>
</div>
</footer>
    <script src="/js/jquery-2.1.0.min.js"></script>
<script type="text/javascript">
  $(document).ready(function(){
    $('.navbar').click(function(){
      $('header nav').toggleClass('shownav');
    });
    var myWidth = 0;
    function getSize(){
      if( typeof( window.innerWidth ) == 'number' ) {
        myWidth = window.innerWidth;
      } else if( document.documentElement && document.documentElement.clientWidth) {
        myWidth = document.documentElement.clientWidth;
      };
    };
    var m = $('#main'),
    a = $('#asidepart'),
    c = $('.closeaside'),
    o = $('.openaside');
    $(window).resize(function(){
      getSize();
      if (myWidth >= 1024) {
        $('header nav').removeClass('shownav');
      }else
      {
        m.removeClass('moveMain');
        a.css('display', 'block').removeClass('fadeOut');
        o.css('display', 'none');
        
            $('#toc.toc-aside').css('display', 'none');
          
      }
    });
    c.click(function(){
      a.addClass('fadeOut').css('display', 'none');
      o.css('display', 'block').addClass('fadeIn');
      m.addClass('moveMain');
    });
    o.click(function(){
      o.css('display', 'none').removeClass('beforeFadeIn');
      a.css('display', 'block').removeClass('fadeOut').addClass('fadeIn');
      m.removeClass('moveMain');
    });
    $(window).scroll(function(){
      o.css("top",Math.max(80,260-$(this).scrollTop()));
    });
  });
</script>

  <script type="text/javascript">
    $(document).ready(function(){
      var ai = $('.article-content>iframe'),
      ae = $('.article-content>embed'),
      t  = $('#toc'),
      h  = $('article h2')
      ah = $('article h2'),
      ta = $('#toc.toc-aside'),
      o  = $('.openaside'),
      c  = $('.closeaside');
      if(ai.length>0){
        ai.wrap('<div class="video-container" />');
      };
      if(ae.length>0){
        ae.wrap('<div class="video-container" />');
      };
      if(ah.length==0){
        t.css('display','none');
      }else{
        c.click(function(){
          ta.css('display', 'block').addClass('fadeIn');
        });
        o.click(function(){
          ta.css('display', 'none');
        });
        $(window).scroll(function(){
          ta.css("top",Math.max(140,320-$(this).scrollTop()));
        });
      };
    });
  </script>


  <script type="text/javascript">
    $(document).ready(function(){
      var $this = $('.share'),
      url = $this.attr('data-url'),
      encodedUrl = encodeURIComponent(url),
      title = $this.attr('data-title'),
      tsina = $this.attr('data-tsina');
      var html = [
        '<a href="#" class="overlay" id="qrcode"></a>',
        '<div class="qrcode clearfix"><span>扫描二维码分享到微信朋友圈</span><a class="qrclose" href="#share"></a><strong>Loading...Please wait</strong><img id="qrcode-pic" data-src="http://s.jiathis.com/qrcode.php?url=' + encodedUrl + '"/></div>',
        '<a href="#textlogo" class="article-back-to-top" title="Top"></a>',
        '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="article-share-facebook" target="_blank" title="Facebook"></a>',
        '<a href="#qrcode" class="article-share-qrcode" title="QRcode"></a>',
        '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="article-share-twitter" target="_blank" title="Twitter"></a>',
        '<a href="http://service.weibo.com/share/share.php?title='+title+'&url='+encodedUrl +'&ralateUid='+ tsina +'&searchPic=true&style=number' +'" class="article-share-weibo" target="_blank" title="Weibo"></a>',
        '<span title="Share to"></span>'
        ].join('');
        $this.append(html);
        $('.article-share-qrcode').click(function(){
          var imgSrc = $('#qrcode-pic').attr('data-src');
          $('#qrcode-pic').attr('src', imgSrc);
          $('#qrcode-pic').load(function(){
            $('.qrcode strong').text(' ');
          });
        });
    });
  </script>


  
  






  <div id="back-to-top">
    <a title="返回顶部"><img src="/img/scrollup.png"/></a>
  </div>
  <script src="/js/back_to_top.js"></script>



  </body>
</html>
